<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[iOS应用剖析 ---- Data目录]]></title>
      <url>/2017/12/20/36/</url>
      <content type="html"><![CDATA[<p>Data目录中最重要的是Application子目录。<br><a id="more"></a><br>Data/Applications目录包含了应用程序运行所需的其他数据：参数设置，缓存，cookie等。这个目录也是需要重点检查的对象。因为大部分数据泄露都发生在这里。下面我来深入的介绍一下这些子目录，当然，目录树中的目录不一定会全部出现在应用的目录中，有一些是使用特定的API创建的。</p>
<h3 id="Documents和Inbox目录"><a href="#Documents和Inbox目录" class="headerlink" title="Documents和Inbox目录"></a>Documents和Inbox目录</h3><p>Documents目录主要用来存储非临时状态的应用数据，比如用户创建的内容或应用程序在离线模式下需要的本地缓存信息。 如果你在应用的Info.plist文件中设置了UIFileSharingEnabled，那么可以通过iTunes访问这些文件。</p>
<p>其他应用发送过来的文件储存在Documents/Index目录中。这些应用可以使用UIDocumentInteractionController类来发送文件。</p>
<p>你只能读取和删除存储在Inbox目录下的文件。这些来自于其他应用程序的文件不能写入你的应用目录里，他们将被一个优先级更高的系统进程处理。 你可以定期删除这些文件也可以让用户选择是否删除，这样用户就可以知道这里有没有敏感信息。</p>
<p>如果你正在开发一个应用想确保磁盘上不会遗留任何敏感信息，那么可以将Inbox目录中的文档复制到另外一个位置，从而对数据进行保护，然后从Inbox目录中移除这些文件。</p>
<p>注意，你的应用程序请求打开的任意文件都有可能永久的遗留在磁盘中。如果你尝试打开一个应用程序无法处理的文件类型，那么这个文件将会被传递给第三方应用，我们无法知道第三方应用是否会将它删除或者也许会将文件永久保留下来。换句话说，你无法清理那些要求第三方应用打开的文件即使只是用Quick Look API来简单预览一下内容。Inbox文件在外面存放太长时间很危险，应该考虑让你的应用能够查看自己的数据，而不是依赖一个帮手，你保证最后正确的清除这些文件。</p>
<h3 id="Library目录"><a href="#Library目录" class="headerlink" title="Library目录"></a>Library目录</h3><p>Library目录包含应用程序相关的大部分文件包括由应用程序和网络产生的缓存数据。Library目录下的文件可以通过iTunes和iCloud进行备份，Cache目录除外。</p>
<h3 id="Application-Support目录"><a href="#Application-Support目录" class="headerlink" title="Application Support目录"></a>Application Support目录</h3><p>由用户创建和接受的文件不会储存在Application Support目录中，该目录主要用来存储应用程序使用的数据文件。例如，一个应用程序内购买的下载内容，配置文件，积分榜等。正如它名字所暗示的那样，该目录下的文件，主要用来支持应用程序运行，这些文件可以在应用程序安装时不熟也可以由应用程序创建或从网络上下载。</p>
<p>默认情况下iiTunes会备份这个目录下的数据到你的计算机和iCloud中。但是如果你不放心将数据保存在苹果的云端也可以通过为新创建的文件设置NSURLIsExcludedFromBackupKey属性来禁止备份到云端。</p>
<p>值得注意的是，苹果只要求应用备份用户数据到iCloud，包括用户创建的文档配置文件等，不要求应用程序备份数据。如果一个应用程序，允许将应用相关的内容备份到iCloud上，比如可下载内容，那么该应用，一定会被App Store拒绝上架。</p>
<h3 id="Caches和Snapshots目录"><a href="#Caches和Snapshots目录" class="headerlink" title="Caches和Snapshots目录"></a>Caches和Snapshots目录</h3><p>Caches目录在功能上类似网页浏览器的缓存：应用程序保留数据的主要目的是为了性能，而不是因为数据本身很重要。所以iTunes不会备份此目录。</p>
<p>虽然苹果声明应该由你的应用程序管理Caches目录但是操作系统，其实也会操作该目录下的内容和子文件夹Snapshots。我们应该形成一种思维定式：Caches目录用来存放临时内容，伴随着应用程序的启动与退出，这些内容将会被丢弃。iOS在系统运行空间不足时也会自动删除这些话传目录，不过并不会删除当前正在运行程序的缓存。</p>
<p>Caches目录有时也会把网页缓存内容存储在子目录Caches/com.mycompany.myapp</p>
<p>中。该位置也容易泄露敏感信息，因为通过https进行长时间传输数据可以被iOS缓存。如果开发者没有禁止数据缓存和尽快使缓存数据过期，那么攻击者总能在这里尝到甜头。</p>
<p>最后，当应用程序，进入后台操作系统会自动把当前应用的屏幕快照存储在Snapshots子目录中，这样做会无形中把一些敏感信息存储在本地。操作系统的初衷是好的：应用被切回前台时操作系统可以使它的屏幕快照创建一个快速的动画。不幸的是，在很多应用中经常看到由此产生的副作用：截图中包含了用户的社会保险号码，用户的详细信息以及其他敏感内容。</p>
<h3 id="Cookies目录"><a href="#Cookies目录" class="headerlink" title="Cookies目录"></a>Cookies目录</h3><p>由URL加载系统所产生的Cookie都存储在Cookies目录中。创建NSURLRequest请求时，你将指定相关的Cookie策略，或者选择系统默认的策略。和OS X不同，iOS上的Cookie不会在应用程序之间共享，每个应用都有单独的目录来存储自己的Cookie。</p>
<h3 id="Preferences目录"><a href="#Preferences目录" class="headerlink" title="Preferences目录"></a>Preferences目录</h3><p>iOS将应用的偏好设置存储在Preferences目录下，但是不允许应用，直接编辑目录中的文件。 取而代之，此目录下文件的创建，读取和操作都通过NSUserDefaults或CFPreferences API来完成。</p>
<p>这些API将应用设置文件已传文本的格式存储，因此绝不能用它们来存储敏感的用户信息和证书。审查一个应用的本地存储信息时一定要记得检查Preference目录中的plist文件。有时候你会在这些plist文件中，发现用户名和密码API访问密钥和不应该暴露给用户的安全设置。</p>
<h3 id="保存应用程序状态的目录"><a href="#保存应用程序状态的目录" class="headerlink" title="保存应用程序状态的目录"></a>保存应用程序状态的目录</h3><p>用户期待应用能够记住他们输入文本框的内容和启用的设置。如果一个用户切换到另外一个应用，片刻后又切回之前的应用，原先的应用可能已经在后台被操作系统杀掉了。为了在应用启动时使它的界面和之前保持一致，新版本的iOS通过State Preservation API将对象状态信息存储在Saved Application State目录中。开发者可以将需要保存状态的UI标记出来。</p>
<h3 id="tmp目录"><a href="#tmp目录" class="headerlink" title="tmp目录"></a>tmp目录</h3><p>正如你猜测的那样，tmp用来存储临时文件。和Caches目录一样，当你的应用程序停止运行时，该目录中包含的文件可能会被操作系统自动删除。此目录的使用方法与Caches目录类似，不同之处在于Caches意味着缓存的这些文件可能会被再次获取和重新创建。比如，你从远程服务器下载了特定的应用数据，然后为了提高性能，会将数据缓存在Caches中，如果输就消失了，可以重新去下载。另一方面tmp严格存储着由应用产生的临时数据，也就是说如果这些文件在重新访问前被删除，你并不能重新获取到他们。此外，和Caches目录一样，tmp也不会被分到iTunes或iCloud中。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Mac终端编写、编译C程序]]></title>
      <url>/2017/12/19/35/</url>
      <content type="html"><![CDATA[<p>在没有编写C语言IDE的情况下，我们可以通过Mac的终端对C语言进行编写与编译。<br><a id="more"></a><br>步骤：创建C文件、用Vim编写C程序、编译C程序文件、执行编译后生成的.out文件。</p>
<ol>
<li><p>$:touch Hello.c               //创建一个Hello.c文件（本目录下）</p>
</li>
<li><p>$:vim Hello.c                  //用vim编辑Hello.c文件</p>
</li>
</ol>
<p>输入 i                                   //打开vim后先输入i进入编辑状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(“Hello Mac ! \n”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ESC键                      //按ESC键退出编辑状态<br>:wq                           //先输入“:”，再输入“w”表示保存，最后输入“q”表示退出</p>
<ol>
<li><p>$:gcc Hello.c             //编译Hello.c文件，会生成可执行文件“a.out”</p>
</li>
<li><p>$:./a.out                    //执行a.out</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS应用剖析 ---- 设备目录]]></title>
      <url>/2017/12/19/34/</url>
      <content type="html"><![CDATA[<p>从iOS8开始，模拟器平台（比如iPhone、iPad以及其他的变体设备）都存储在以唯一标识符命名的目录下。这些标识符由两部分组成：一部分是从Xcode启动模拟器时选择的设备类型，另一部分是系统版本。所有目录都有一个plist文件记录当前的设备信息。<br><a id="more"></a><br>从iOS8开始，模拟器平台（比如iPhone、iPad以及其他的变体设备）都存储在以唯一标识符命名的目录下。这些标识符由两部分组成：一部分是从Xcode启动模拟器时选择的设备类型，另一部分是系统版本。所有目录都有一个plist文件记录当前的设备信息。</p>
<p>在这个plist文件中，想找出设备信息并不容易。为了找出设备信息，要么去Devices目录下查看.default_created.plist文件，要么使用grep命令找出所有的device.plist文件。<br>打开终端，输入(这里举例子，具体路径还要根据自己的电脑酌情改变)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd /User/me/Library/Developer/CoreSimulator/Devices &amp;&amp; ls</span><br><span class="line"></span><br><span class="line">$ for dir in &apos;ls|grep -v default&apos;</span><br><span class="line">do</span><br><span class="line">echo $dir</span><br><span class="line">grep -Cl name $dir/device.plist |tail -l|sed -e &apos;s/&lt;/\*string&gt;//g&apos;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>进入正在运行的应用程序目录后，你会看到data目录，它包含所有的模拟器文件，还包括应用的相关数据。应用数据被分别放到了三个目录中，他们在data/Containers目录下，分别是Bundle、Data和Shared目录。<br>这篇文章主要介绍一下Bundle和Shared目录，关于Data目录内容较多，下一篇文章单独介绍。</p>
<h3 id="Bundle目录"><a href="#Bundle目录" class="headerlink" title="Bundle目录"></a>Bundle目录</h3><p>Bundle目录中有一个Applications目录，该目录包含设备上的所有的应用目录，这些应用目录用应用程序的bundle ID命名。</p>
<p>在应用目录中，.app文件夹存储应用程序的核心二进制代码、图像资源、本地化信息等；info.plist文件包含应用程序的核心配置信息，包括bundle标识、主程序包、应用程序的UI信息以及应用程序需要向设备请求的功能。</p>
<p>在文件系统中，这些plist会以XML或二进制格式进行存储，后者通常是默认的存储方式。你可以通过代码的方式获取info.plist中的信息，及引用[NSBundle mainBundle]中的字典属性；一般通过这种方式来载入一些样式或本地化信息。</p>
<p>info.plist文件中值得我们关注的条目是UIRequiredDeviceCapabilities，他看上去像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIRequiredDeviceCapabilities&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;armv7&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;location-services&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;sms&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>
<p>UIRequiredDeviceCapabilities描述了应用所需要的系统资源。<br>虽然这不是强制要求的，但还是暗示了这个应用将涉及哪些活动类型。</p>
<h3 id="Shared目录"><a href="#Shared目录" class="headerlink" title="Shared目录"></a>Shared目录</h3><p>Shared目录是一个特殊的目录，用来为应用程序提供一个共享的应用组(为了支持iOS8的扩展extensions)，比如通知中心的“今日”视图中的任务或键盘行为，widget。苹果要求所有的扩展必须对应一个容器应用，每一个容器应用会拥有自己的应用ID。扩展及其应用容器可以通过Shared目录来共享数据。</p>
<p>例如，用户可以使用NSUserDefaults的初始化方法，制定一个名字来访问用户数据中共享的数据库。</p>
<p>Shared目录不常用，但是当我们检查存储在perferences中的敏感信息或其他隐私数据时，别忘了它。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS应用剖析 ---- 对plist文件进行处理]]></title>
      <url>/2017/12/18/28/</url>
      <content type="html"><![CDATA[<p>想要理解iOS应用所面临的某些问题，最好能熟知应用如何存储和操作私有目录下的各种数据，包括配置文件、资源文件、二进制我呢间以及文档。在这里你会发现各种信息的泄露方式，同时也能深入理解应用程序的核心。<br><a id="more"></a><br>要找出应用在本地存储的所有数据，最快的方法是查看~/Library/Developer/CoreSimulator/Devices目录。从Xcode6开始，只要在模拟器上运行过的应用，Xcode都会根据当前设备类型和系统版本建立一个文件夹并分配一个UUID。相关应用的数据也会被存储在这里。其中应用的二进制和资源文件(包括.nib文件和图形文件)都放置在<device id="">/data/Containers/Bundle/Application/<app bundleid="">目录下。而经常变化的动态数据则存储在~<device id="">/data/Containers/Data/Application/<app bundleid="">目录中。系统数据(如全局配置文件)将存储在其余的目录下。</app></device></app></device></p>
<p>如果你的设备已经越狱，那么你可以使用SSH连接到设备，并研究一下它的目录结构。但是你也可以使用iExplorer这样的工具来查看和安装应用程序的目录结构，不论你越狱与否。</p>
<h3 id="对plist文件进行处理："><a href="#对plist文件进行处理：" class="headerlink" title="对plist文件进行处理："></a>对plist文件进行处理：</h3><p>iOS将应用程序的配置数据存储在属性列表(plist)文件里，这些信息都是CoreFoundation数据类型，比如CFArray和CFString。从安全角度来说，你需要重点检查plist文件中不是纯文本的值，比如证书，他们有可能会被修改从而改变应用程序的行为。</p>
<p>举个例子：默认情况下支付功能是金庸的，但是当相应的值被修改时，该功能就可使用。</p>
<p>属性列表有两种格式：二进制和XML。XML文件具有良好的可读性。其中的配置文件里存储了程序的基本信息，包括该应用能够运行的平台，代码签名等(在模拟器上运行的程序是不会显示代码签名的)</p>
<p>如果用命令行查看文件或在代码中处理plist，就会经常遇到二进制格式的plist文件。二进制文件的可读性与可写性就不是那么理想了，但是你可以使用plutil(1)命令将plist文件转换成XML格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ plutil -convert xml1 Info.plist -o -</span><br><span class="line">$ plutil -convert xml1 Info.plist -o Info-xml.plist</span><br><span class="line">$ plutil -convert binary1 Info-xml.plist -o Info-bin.plist</span><br></pre></td></tr></table></figure></p>
<p>第一条命令将一个二进制的plist转换成XML，然后打印到标准输出(stdout)，之后可以通过管道(pipe)把内容传给less(1)或者类似的命令。当然你也可以向第二条命令那样，使用-o filename参数直接将内容输出到一个文件。第三条命令，binary1转换类型，将XML格式的plist转换为二进制格式。不过两种格式系统都能识别，所以一般不做转换。</p>
<p>为了无缝读取和编辑plist，可以提前配置好你的文本编辑器，使其在读写plist文件的时候自动转换。。你可以在你所熟悉的环境里配置，比如你习惯用Vim，那么就可以在.vimrc配置文件中添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">command -bar PlistXML :set binary | :1,$!plutil -convert xml1 /dev/stdin -o -</span><br><span class="line">command -bar Plistbbin :1,$!plutil -convert binary1 /dev/stdin -o -</span><br><span class="line"></span><br><span class="line">func ReadPlist()</span><br><span class="line">    if getline(&quot;&apos;[&quot;) =~ &quot;^bplist&quot;</span><br><span class="line">        :PlistXML</span><br><span class="line">        set filetype=xml</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">augroup misc</span><br><span class="line">au BufWinEnter *.plist, call ReadPlist()</span><br><span class="line">augroup end</span><br></pre></td></tr></table></figure></p>
<p>这个配置使用:PlistXML命令自动将需要编辑的二进制格式plist转换为XML文件，从而在肉眼可读的情况下对文件进行修改。当我们准备将这些修改保存到文件中时，改文件将再次使用:Plistbin命令将XML转换成二进制进行保存。<br>你可以使用Xcode查看plist文件，优势在于他可以用下拉菜单来显示所有可用的键，这些键对应不同类型的值。不过你最好掌握在命令行中处理plist文件的做法，这样将来可以通过SSH与越狱设备进行交互。</p>
<p>可以通过man手册来查看更多关于plist(5)和plutil(1)的信息。如果你正在使用越狱设备，则可以直接使用Erica Sadum的Erica Utilities（可以在Cydia下载安装）中的plutil命令在设备上处理plist文件。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 11适配：contentInsetAdjustmentBehavior解析]]></title>
      <url>/2017/12/13/27/</url>
      <content type="html"><![CDATA[<p>上一篇一篇文章介绍了影响页面布局的几个属性，如今iOS 11出来后变化挺大的，在这里重新梳理下。<br><a id="more"></a><br>可以看到在iOS 11中，UIViewController的automaticallyAdjustsScrollViewInsets属性被弃用了，系统推荐我们使用UIScrollView的contentInsetAdjustmentBehavior属性替代之。关于这个属性，系统提供了四种行为模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIScrollViewContentInsetAdjustmentAutomatic</span><br><span class="line">UIScrollViewContentInsetAdjustmentScrollableAxes</span><br><span class="line">UIScrollViewContentInsetAdjustmentNever</span><br><span class="line">UIScrollViewContentInsetAdjustmentAlways</span><br></pre></td></tr></table></figure></p>
<p>第3、4种看起来比较清晰，要么不调整，要么”一直”调整。但估计不少朋友看到第1、2种会一脸懵逼，包括第4种里“一直”这个词。在这解释之前我们先分析下为什么automaticallyAdjustsScrollViewInsets会被弃用。</p>
<p>在我看来原因可能之前使用automaticallyAdjustsScrollViewInsets的方案太单调粗暴了。当处于 ①(文末末尾)情况时的scrollView，系统会自动修改其contentInset属性，举个例子:如果存在状态栏和导航栏，则contentInset的top值则会被修改为64，内容自动下移64。当底部存在系统UITabBar时，则bottom值修改为49，即下方额外增加49的滚动距离。</p>
<p>我们知道iOS 11后引入了安全区的概念safeAreaInsets。</p>
<img src="/2017/12/13/27/1970468-e93887c3ec1be77e.jpg">
<p>以不带UITabBar的iPhone X为例：NavigationController的rootViewController.view（以下用self代称该rootViewController）,其safeAreaInsets为{88, 0, 34, 0}，在contentInsetAdjustmentBehavior属性出现之前，系统是根据①情况进行的调整。而现在，系统将会根据ScrollView视图大小(包括其类族UITableView等)是否超过了安全区来进行调整，需要注意的有两点：</p>
<ol>
<li><p>这个”调整”不再是直接修改scrollView.contentSize，而是scrollView.adjustedContentInset</p>
</li>
<li><p>调整的值将根据具体超出多少值来确定，但最大值不能超过安全区的相应EdgeInsets方向的值。以self.view的safeAreaInsets为{88, 0, 34, 0}为例。此时添加一个tableView，其高度为self.view.short_height + 25，那么tableView.adjustedContentInset的bottom则为25。但如果超出高度为134，bottom最高也只会是34，这样就会由于表格高度超过屏幕100，而出现”拉不到底部”的情况。</p>
</li>
</ol>
<p>第二点的效果相比以前的automaticallyAdjustsScrollViewInsets方案，可以说智能很多，因为当处于①情况时，哪怕你的scrollView的布局位置根本就没被导航栏挡住，它都会给你调整64。然后你就发现莫名起妙内容就被下移了。</p>
<img src="/2017/12/13/27/1970468-86b43da6709859fe.png">
<p>接下来我们再说回contentInsetAdjustmentBehavior属性的这四个值：</p>
<p>首先是UIScrollViewContentInsetAdjustmentNever，如名所示：就算你的ScrollView超出了safeAreaInsets，系统不会对你的scrollView.adjustedContentInset做任何事情，即不作任何调整；</p>
<p>UIScrollViewContentInsetAdjustmentAlways: 只要超了安全区，就调整相应的超出值，调整的最大值不会超过安全区相应EdgeInsets方向的最大值，如刚刚上述第2点；</p>
<p>UIScrollViewContentInsetAdjustmentScrollableAxes：系统会根据ScrollView的滚动方向来进行判断，假设我只是一个横向滚动的ScrollView，那即便我的布局起点和高度值超过了self.view的安全区，那么系统也不会调整scrollView.adjustedContentInset对应的top与bottom方向值，只可垂直方向滚动同理，直接设置scrollView.scrollEnabled = NO也同理；</p>
<p>UIScrollViewContentInsetAdjustmentAutomatic：系统默认值。文档上是这样说的：</p>
<blockquote>
<p>Similar to .scrollableAxes, but for backward compatibility will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller,</p>
</blockquote>
<p>其实文档已经说的很清楚了，它与UIScrollViewContentInsetAdjustmentScrollableAxes行为相似，但是为了兼容以前①这种情况，即使scrollView是不可滚动，也会根据safeAreaInsets超出范围进行调整。（具体效果可以试着自己上手调试，这里就不贴代码和示意图了）。</p>
<p>关于刚才说的注意点二，我想补充的是，当出现表格过高(比如超出了100)而导致”拉不到底部”的情况时，你可以选择额外设置tableView.contentInset属性，bottom方向设为100，或者选择修改self.additionalSafeAreaInsets的属性。前者影响tableView.adjustedContentInset值，后者影响self.view.safeAreaInsets。你会发现刚好是两数之和，事实上adjustedContentInset的值正是由contentSize加上contentInsetAdjustmentBehavior所调整的值。而self.view.safeAreaInsets会在原来的基础上，加上你的additionalSafeAreaInsets。由于我们很少直接修改contentSize，所以基本上tableView.adjustedContentInset都是系统的调整值。</p>
<p>其实，苹果可能本意是方便开发者，但事实上如果你对这些属性的来龙去脉不太了解清楚的话，确实是挺不方便的。。。因此可能现在很多的人做法都是一开始就设置之前的automaticallyAdjustsScrollViewInsets为NO，设置新的contentInsetAdjustmentBehavior为UIScrollViewContentInsetAdjustmentNever。就我个人看来，如果你需要实现类似系统默认那种表格穿透半透明导航栏或者底部半透明TabBar的效果时，这个属性使用起来就很舒服，直接tableView.frame = self.view.bouds 或者make.edges.equal.to(self.view)就好了。而无需再设置额外的contentSize。如果不需要类似的穿透，那可以选择直接将其禁止。</p>
<p>① scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller<br>PS：并且该scollView是第一个被添加的子视图</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中class func与static func的区别]]></title>
      <url>/2017/12/13/23/</url>
      <content type="html"><![CDATA[<p>在开发过程中遇到了这么一个问题，有些人喜欢用class func来写静态方法，有些人则喜欢用static func来写静态方法。其实从翻译的角度来说，static func叫作静态方法更合适一些。<br><a id="more"></a><br>在开发过程中遇到了这么一个问题，有些人喜欢用class func来写静态方法，有些人则喜欢用static func来写静态方法。其实从翻译的角度来说，static func叫作静态方法更合适一些。<br>这里为了明确两者区别，可以做一个简单的实验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">    class func func1() -&gt; String &#123;</span><br><span class="line">        return &quot;func1&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func func2() -&gt; String &#123;</span><br><span class="line">        return &quot;func2&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class final func func3() -&gt; String &#123;</span><br><span class="line">        return &quot;func3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassB : ClassA &#123;</span><br><span class="line">    override class func func1() -&gt; String &#123;</span><br><span class="line">        return &quot;func1 in ClassB&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ERROR: Cannot override static method</span><br><span class="line">    override static func func2() -&gt; String &#123;</span><br><span class="line">        return &quot;func2 in ClassB&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // ERROR: Class method overrides a &apos;final` class method</span><br><span class="line">    override class func func3() -&gt; String &#123;</span><br><span class="line">        return &quot;func3 in ClassB&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码可以看出，其实在Swift中static func 相当于class final func。禁止这个方法被重写。</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[影响导航控制器中页面布局的几个属性]]></title>
      <url>/2017/12/13/26/</url>
      <content type="html"><![CDATA[<p>关于iOS的适配一直有许许多多的坑，今天来简单说一下最主要的几个影响布局的属性。<br><a id="more"></a></p>
<h3 id="先来介绍几个主要属性"><a href="#先来介绍几个主要属性" class="headerlink" title="先来介绍几个主要属性"></a>先来介绍几个主要属性</h3><blockquote>
<p>UIViewController 的 edgesForExtendedLayout<br>UIViewController 的 extendedLayoutIncludesOpaqueBars<br>UIViewController 的 automaticallyAdjustsScrollViewInsets<br>NavigationBar 的 translucent</p>
</blockquote>
<ol>
<li><p>edgesForExtendedLayout属性的系统默认值为UIRectEdgeAll：意味着当导航控制器的导航栏为半透明效果时，子控制器self.view布局的起始位置将从屏幕边缘左上角开始。</p>
</li>
<li><p>extendedLayoutIncludesOpaqueBars属性系统默认为NO，Opaque代表非透明，not Includes意味着导航栏不是半透明时，即便当前是UIRectEdgeAll，self.view的布局起始位置依旧是从导航栏下方开始。</p>
</li>
<li><p>translucent属性值会决定导航栏是否有半透明效果。translucent为NO，意味着导航栏为非透明，此时如上文所述，即便当前是UIRectEdgeAll，由于extendedLayoutIncludesOpaqueBars为默认NO，self.view的布局起始位置依旧是从导航栏下方开始。</p>
</li>
<li><p>至于automaticallyAdjustsScrollViewInsets属性，系统默认值为YES。意味着当导航控制器的childViewController.view的上层视图为scollView类簇时，则系统会自动为该scrollView的contentInset(内边距属性)的Top值增加额外的64，于是内容就会下移64。</p>
</li>
</ol>
<h3 id="关于translucent属性需要特别注意的是："><a href="#关于translucent属性需要特别注意的是：" class="headerlink" title="关于translucent属性需要特别注意的是："></a>关于translucent属性需要特别注意的是：</h3><blockquote>
<p>根据官方文档所述：translucent会受navigationBar的backgroudImage属性的影响。也就是说当你使用了一张自定义图片作为navigationBar的背景图时，translucent的值将由系统根据该图片是否颜色值透明，来推断translucent是YES还是NO。</p>
</blockquote>
<p>于是坑就来了：对于导航控制器中的各个childViewController，是共用同一个的navigationBar。当你在一个childViewController中自定义了navigationBar的背景图片，或是直接改变了translucent属性，此时再push或pop到另一个childViewController时，更改导航栏的半透明效果可能会影响到页面的布局起始位置，从而发生视图发生跳动，出现“意外”的上下偏移。</p>
<p>举个例子：从一个设置了导航栏不透明的控制器A，pop回到一个原本设置了导航栏透明的控制器B时，B页面发生了下移。</p>
<blockquote>
<p>为避免该情况，应该将控制器B的extendedLayoutIncludesOpaqueBars设置为YES；或是当B页面viewWillAppear:时，再度将导航栏设置为半透明效果。</p>
</blockquote>
<h3 id="关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是"><a href="#关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是" class="headerlink" title="关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是"></a>关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是</h3><blockquote>
<p>以tableView为例，当你使用默认的创建方式，也就是UIRectEdgeAll+导航栏半透明的情况下，首行cell的位置将处于导航栏下方，也就是屏幕坐标系的(0, 64)位置处，此时上滑将会形成穿透效果导航栏的效果。</p>
</blockquote>
<p>补充：当你的设计中出现导航栏穿透效果，自定义非透明的导航栏背景、导航栏完全透明等需求时，记得结合上述几点进行判断处理，避免发生预想之外的界面偏差。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS11 UITableView顶部多出一片空白区域]]></title>
      <url>/2017/12/13/25/</url>
      <content type="html"><![CDATA[<p>苹果向来都是出个bug让开发者填坑，这不弄了个iPhone X的异形屏幕，既要考虑顶部的齐刘海，又要考虑底部的home条。现在不光是iPhone X的屏幕问题，iOS 11的SDK也有好多改变，其中影响最大的莫过于UITableView的改动。<br><a id="more"></a><br>很多开发者发现了，用iOS 11的SDK运行程序后tableView变得自己都不认识了。</p>
<p>首先是在iOS 11中，tableView关于footer的两个代理方法必须成对出现，不然就会有问题。这里以footer为例，header同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section</span><br><span class="line">-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section</span><br></pre></td></tr></table></figure></p>
<p>这两个方法只要出现一个，另一个就必须写上。不然footer的高度就无法控制了。。</p>
<p>其次，很多人发现自己的tableView下移了64个像素。</p>
<p>在iOS11之前，如果想要scrollView不偏移64p，则需设置automaticallyAdjustsScrollViewInsets=NO，但是这个属性在iOS11直接被遗弃了。。</p>
<p>多出了一个新属性contentInsetAdjustmentBehavior，类型是UIScrollViewContentInsetAdjustmentBehavior。看起来这和iOS11搞的safeArea有关，这个先放一边，看看怎么适配(一种简单方案)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">    tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Fallback on earlier versions</span><br><span class="line">    self.automaticallyAdjustsScrollViewInsets = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看一下这个新的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIScrollViewContentInsetAdjustmentBehavior) &#123;</span><br><span class="line">    UIScrollViewContentInsetAdjustmentAutomatic, // Similar to .scrollableAxes, but will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewContentInset = YES inside a navigation controller, regardless of whether the scroll view is scrollable</span><br><span class="line">    UIScrollViewContentInsetAdjustmentScrollableAxes, // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)</span><br><span class="line">    UIScrollViewContentInsetAdjustmentNever, // contentInset is not adjusted</span><br><span class="line">    UIScrollViewContentInsetAdjustmentAlways, // contentInset is always adjusted by the scroll view&apos;s safeAreaInsets</span><br><span class="line">&#125; API_AVAILABLE(ios(11.0),tvos(11.0));</span><br></pre></td></tr></table></figure></p>
<p>关于这个属性我会在另一篇文章中详细解释一下。</p>
<p>下面是一种大神的解决方案，是从网上找的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define  adjustsScrollViewInsets_NO(scrollView,vc)\</span><br><span class="line">do &#123; \</span><br><span class="line">    _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic ignored \&quot;-Warc-performSelector-leaks\&quot;&quot;) \</span><br><span class="line">    if ([UIScrollView instancesRespondToSelector:NSSelectorFromString(@&quot;setContentInsetAdjustmentBehavior:&quot;)]) &#123;\</span><br><span class="line">        [scrollView   performSelector:NSSelectorFromString(@&quot;setContentInsetAdjustmentBehavior:&quot;) withObject:@(2)];\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        vc.automaticallyAdjustsScrollViewInsets = NO;\</span><br><span class="line">    &#125;\</span><br><span class="line">    _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure></p>
<p>这种方法是利用了宏定义。但是在iOS 11的SDK中，我发现有的时候宏定义或者全局变量的值并不是我所期望的值，使用NSLog打印的值跟通过计算后得到的值匹配不上。我不确定这是Xcode9的bug还是其他什么原因，特别是计算frame的时候，明明单独打印这几个宏定义的值都对，但是把这几个宏定义进行计算，得到的结果却是错误的。。如果有人遇到了同样的问题，麻烦私信我一下。。一起探讨探讨。</p>
<p>最后希望所有的产品经理都紧跟苹果步伐。抛弃旧的系统。。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Win7x64+VS2015Pro+Matlab2016b+OpenCV3.2配置运行TLD]]></title>
      <url>/2017/12/06/21/</url>
      <content type="html"><![CDATA[<p>TLD即Tracking Learning Detection，Zdenek Kalal大神在其<a href="http://info.ee.surrey.ac.uk/Personal/Z.Kalal/tld.html" target="_blank" rel="noopener">主页上给出的代码</a>，是一种实时更新学习库的神级跟踪算法。ZK大神成功的利用这个算法开了一家公司，并且现在已经更新到2.2版本了，放到平板、电脑、工作站中都可以完美运行，已经做到了商业化。虽然开源代码是2011年写的，但是放到现在来说仍有重要的学习意义。<br><a id="more"></a><br>TLD即Tracking Learning Detection，Zdenek Kalal大神在其主页上给出的代码，是一种实时更新学习库的神级跟踪算法。ZK大神成功的利用这个算法开了一家公司，并且现在已经更新到2.2版本了，放到平板、电脑、工作站中都可以完美运行，已经做到了商业化。虽然开源代码是2011年写的，但是放到现在来说仍有重要的学习意义。</p>
<p>先说一下，我电脑的程序配置:WIN7x64+VS2015pro+MATLAB2016b+OpenCV3.2，一开始，这个程序在我电脑上始终没有跑起来，我通过在网上找到各种资料进行拼凑，却仍然不能正常运行，以至于一度想要将软件配置成几年前的版本（因为网上有前辈用WIN7+VS2005+MATLAB2011a+OpenCV2.2运行起来了，我的部分资料也是借鉴他的）。</p>
<p>鉴于所有的配置都是几年前的老套路，而OPENCV也已经更新到3.2（今天刚看了下cv的官网，8月初更新到了3.3。。。。。。）。我决定自己总结一篇最新的配置方法。</p>
<p>跑TLD程序，首先应该运行compile.m程序，然后再运行run_TLD.m，在任何机器上，首先得保证matlab的mex命令设置正确，其可通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mex –setup</span><br></pre></td></tr></table></figure></p>
<p>配置好所用VS的编译环境，相关教程不少，之前因为我已经配置过了，此处就省略此步骤。之后打开compile.m<br>源代码中有如下两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include = &apos; -Ic:\OpenCV2.2\include\opencv\ -Ic:\OpenCV2.2\include\&apos;;</span><br><span class="line">libpath = &apos;c:\OpenCV2.2\lib\&apos;;</span><br></pre></td></tr></table></figure></p>
<p>需要改为自己的opencv路径，我的电脑上opencv路径为：<br><img src="/2017/12/06/21/20170829113954171.png"></p>
<p>当然这些只是针对windows pc改的，若换成其它系统环境，则在相应的地方更改。<br>注意，此处有一个问题：我有段时间一直编译不通过其实就是因为lib后面没加’\’，网上的大神都没加。。。<br><img src="/2017/12/06/21/20170829113839057.png"><br>少掉这个“\”会出现如下情况：<br><img src="/2017/12/06/21/20170829114108233.jpeg"></p>
<p><a href="https://github.com/zk00006/OpenTLD/wiki/Installation" target="_blank" rel="noopener">根据作者的说法</a> ：若用VS2010会有不同：<br>You will need some extension toolboxes for Matlab, see below.</p>
<p>1) Install OpenCV2.2: compile OpenCV, set system PATH variable to link to OpenCV DLLs</p>
<p>2) Setup mex compiler in Matlab: run: mex -setup, select Visual Studio 2010 compiler from the list</p>
<p>3) Compilation of mex files: check paths in ‘compile.m’ file, run ‘compile.m’</p>
<p>3.1) If you are using Matlab 2011a, in TLD source, comment out the following lines in lk.cpp, fern.cpp, and bb_overlap.cpp (Otherwise, you will get an error about int being undefined which is a no-no in 2010):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _CHAR16_T</span><br><span class="line">#define CHAR16_T</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>4) run ‘run_TLD.m’, TLD should track a motorbike<br>即如红色部分所示，你需要把<br>lk.cpp, fern.cpp, and bb_overlap.cpp 这几个文件中的这几行代码注释掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _CHAR16_T</span><br><span class="line">#define CHAR16_T</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>但是我在VS2015pro上没有注释掉这几行。结果并没有什么影响，最后还是可以运行的。</p>
<p>按照网上的步骤进行修改后，我又遇到了一个比较恶心的问题，在运行compile.m时，提示我说：<br><img src="/2017/12/06/21/20170829114329806.png"></p>
<p>what??min和max不是在Cpp中有定义的吗？之后看网上的前辈说将#include <stdafx.h>加入头文件可以解决此问题，于是加入后出现：<br><img src="/2017/12/06/21/20170829114414527.png"></stdafx.h></p>
<p>好吧，彻底被打败了。（我一直在想为什么matlab调用的是VS进行编译竟然还找不到VS的头文件库。有知道的大神告诉我一下），既然调用头文件不能用的话，那就自己写一个定义吧：<br><img src="/2017/12/06/21/20170829114522568.jpeg"><br>之后再运行compile.m，无报错.</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xcode8,Xcode9 查看模拟器沙盒目录的方法]]></title>
      <url>/2017/12/05/12/</url>
      <content type="html"><![CDATA[<p>自从升级到Xcode8之后，所有的插件都被禁用了，那么应该如何进入模拟器的沙盒目录呢？<br><a id="more"></a><br>自从升级到Xcode8之后，所有的插件都被禁用了，那么应该如何进入模拟器的沙盒目录呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray * paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSLog(@&quot;%@&quot;, paths[0]);</span><br></pre></td></tr></table></figure></p>
<p>打开Finder，点前往<br>把打印出来的path复制到输入框中按回车即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo中的Yelee主题，首页不显示文章摘要]]></title>
      <url>/2017/12/04/2/</url>
      <content type="html"><![CDATA[<p>最近在用Hexo自己搭建博客，使用了文档比较全的Yelee主题，但是在使用过程中发现了一个大问题，在所有文章列表中有文章，但是首页却不显示文章摘要。<br><a id="more"></a><br>最近在用Hexo自己搭建博客，使用了文档比较全的Yelee主题，但是在使用过程中发现了一个大问题，在所有文章列表中有文章，但是首页却不显示文章摘要。</p>
<p>我找了一下，发现是themes/yelee/layout/_partial/head.ejs中的这段代码的search: &lt;%= theme.search.on %&gt;定义有问题。</p>
<p>具体代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var yiliaConfig = &#123;</span><br><span class="line">    fancybox: &lt;%=theme.fancybox%&gt;,</span><br><span class="line">    animate: &lt;%=theme.animate%&gt;,</span><br><span class="line">    isHome: &lt;%=is_home()%&gt;,</span><br><span class="line">    isPost: &lt;%=is_post()%&gt;,</span><br><span class="line">    isArchive: &lt;%=is_archive()%&gt;,</span><br><span class="line">    isTag: &lt;%=is_tag()%&gt;,</span><br><span class="line">    isCategory: &lt;%=is_category()%&gt;,</span><br><span class="line">    fancybox_js: <span class="string">"&lt;%- theme.CDN.fancybox_js %&gt;"</span>,</span><br><span class="line">    scrollreveal: <span class="string">"&lt;%- theme.CDN.scrollreveal %&gt;"</span>,</span><br><span class="line">    search: &lt;%= theme.search.on %&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看这里最后一个search，里面用的是on，而在yelee主题的_config.xml里默认设置是search:onload:false，这里写的是onload而不是on，导致Uncaught ReferenceError: yiliaConfig is not defined。</p>
<p>解决方法是把两边的变量名改成一样就可以了，比如yelee主题的_config.xml里面的search:onload false改成search:on false，这样就正常运行了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Windows电脑上给Python配置OpenCV]]></title>
      <url>/2017/12/01/22/</url>
      <content type="html"><![CDATA[<p>许多开发者想在PYTHON中配置OPENCV，但又不知道怎么做，最近一直在搞这一方面，也是混沌了好几天，最后终于有了些眉目，和大家分享一下<br><a id="more"></a><br>许多开发者想在PYTHON中配置OPENCV，但又不知道怎么做，最近一直在搞这一方面，也是混沌了好几天，最后终于有了些眉目，和大家分享一下：</p>
<h2 id="安装PYTHON"><a href="#安装PYTHON" class="headerlink" title="安装PYTHON"></a>安装PYTHON</h2><p>我用的是python3.5版本，官网就能下，跟着教程走，配置好PATH包就能在C字命令符中调用了，调用结果如下：<br><img src="/2017/12/01/22/20170310104620566.jpeg"><br>按回车后：<br><img src="/2017/12/01/22/20170310104638243.jpeg"></p>
<h2 id="安装opencv之前要干的工作"><a href="#安装opencv之前要干的工作" class="headerlink" title="安装opencv之前要干的工作"></a>安装opencv之前要干的工作</h2><p>第二步开始，均是在C字命令符下操作！！！！！均是在C字命令符下操作！！！！！均是在C字命令符下操作！！！！！重要的事情说三遍</p>
<p>安装opencv之前要干的工作：<br>C字命令符中输入：<br>python -m pip install -U pip<br>按回车，自动安装pip包<br>之后下载numpy和opencv的python3.5版本：</p>
<p>这里给出几个网站：<br>Numpy：   <a href="https://pypi.python.org/pypi/numpy" target="_blank" rel="noopener">https://pypi.python.org/pypi/numpy</a></p>
<img src="/2017/12/01/22/20170310104653489.jpeg">
<p>看这些很乱看不懂对吧？其实很简单：</p>
<p>最长的都是土豪专用OSX版本。</p>
<p>处于中间不长不短的是Linux系统的。</p>
<p>最短的都是windows32位的版本（这的位数指的是python的！！！！不是系统的！！！32位系统也是可以安装64位python的！！！）。嗯，剩下的amd64就是windows用64位版本的。</p>
<p>之后cp27,34,35,36指的就是PYTHON的2.7  3.4  3.5  3.6版本，下载对应版本的就可以了。</p>
<p>我下的是numpy-1.12.1rc1-cp35-none-win_amd64.whl (md5, pgp)</p>
<p>Opencv：<a href="http://www.lfd.uci.edu/%7Egohlke/pythonlibs/#opencv" target="_blank" rel="noopener">http://www.lfd.uci.edu/%7Egohlke/pythonlibs/#opencv</a><br>进入之后会发现乱七八糟一大堆。。。</p>
<img src="/2017/12/01/22/20170310104706145.jpeg">
<p>看到红圈了吗。。。那就是opencv，点一下就到了下载opencv的地方了。。如下图：</p>
<img src="/2017/12/01/22/20170310104724025.jpeg">
<p>这里要下哪个就不用多说了，解释见上，命名方式都一样。<br>我用的是：opencv_python‑3.2.0+contrib‑cp35‑cp35m‑win_amd64.whl<br>至于多了个contrib，是多了些高级功能的包包，具体作用可以百度，问题不大。</p>
<h2 id="Opencv安装包的问题"><a href="#Opencv安装包的问题" class="headerlink" title="Opencv安装包的问题"></a>Opencv安装包的问题</h2><p>下载完后，你会得到两个.whl包包：然后放置在C字命令符开始的目录下（这样就不用你自己再填写路径了！！！！）：<br>注意！！！<br>对于opencv安装包<br>改之前：opencv_python‑3.2.0+contrib‑cp35‑cp35m‑win_amd64.whl<br>一定要把cp35m改成none！！<br>改之后：opencv_python‑3.2.0+contrib‑cp35‑none‑win_amd64.whl</p>
<p>如果不改的话不然会出现：<br>opencv_python-3.2.0+contrib-cp35-cp35m-win_amd64.whl is not a supported wheel on this platform.</p>
<img src="/2017/12/01/22/20170310104745068.jpeg">
<h2 id="安装Opencv"><a href="#安装Opencv" class="headerlink" title="安装Opencv"></a>安装Opencv</h2><p>安装，C字命令符中输入<br>pip3 install numpy-1.12.1rc1-cp35-none-win_amd64.whl<br>安装numpy<br>输入pip3 install opencv_python‑3.2.0+contrib‑cp35‑none‑win_amd64.whl</p>
<img src="/2017/12/01/22/20170310104756600.jpeg">
<p>忽略画叉的那些，下边这个就是安装成功后的样子。</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用~"></a>开始使用~</h2><p>打开python3.5.2 shell，不是像c字命令符的那个！！！！！<br>输入improt cv2回车</p>
<img src="/2017/12/01/22/20170310104808741.jpeg">
<p>无报错，安装成功</p>
<p>最后吐槽一下这些网站。。写个漂亮点的CSS就这么难么。</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 设置Launchpad 的列数和行数]]></title>
      <url>/2017/11/13/3/</url>
      <content type="html"><![CDATA[<p>这两天在搞博客的事情，发现Mac的Launchpad里面一页显示的东西太少，很不方便，于是就搜集了一下如何让她显示更多图标的方法。<br><a id="more"></a></p>
<p>打开终端。</p>
<ol>
<li><p>设置 Launchpad 的列数，对应于每一行 App 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-columns -int 列数</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 Launchpad 的行数，对应于每一列 App 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows -int 行数</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置 Launchpad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置 Dock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[加密和签名的区别]]></title>
      <url>/2017/11/08/4/</url>
      <content type="html"><![CDATA[<p>最近在研究RSA，对其中的签名和加密的概念不是很理解，从网上搜了搜，在这里总结一下。<br><a id="more"></a><br>最近在研究RSA，对其中的签名和加密的概念不是很理解，从网上搜了搜，在这里总结一下。</p>
<p>举个例子，就拿A给B发送经过签名加密信息来说：<br>1、A对信息签名的作用是确认这个信息是A发出的，不是别人发出的；<br>2、加密是对内容进行机密性保护，主要是保证信息内容不会被其他人获取，只有B可以获取。也就是保证整个过程的端到端的唯一确定性，这个信息是A发出的（不是别人），且是发给B的，只有B才被获得具体内容（别人就算截获信息也不能获得具体内容）。</p>
<p>这只是大概说了作用，具体说来，涉及到密钥相关的东西。密钥有公钥和私钥之分。</p>
<p>那么这里一共有两组四个密钥：<br>A的公钥（PUB_A），A的私钥（PRI_A）；B的公钥（PUB_B），B的私钥（PRI_B）。</p>
<p>公钥一般用来加密，私钥用来签名。</p>
<p>通常公钥是公开出去的，但是私钥只能自己私密持有。<br>公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；同样用某个私钥加密的内容只能用对应的公钥才能解密。</p>
<p>这时A向B发送信息的整个签名和加密的过程如下：<br>1、A先用自己的私钥（PRI_A）对信息（一般是信息的摘要）进行签名。<br>2、A接着使用B的公钥（PUB_B）对信息内容和签名信息进行加密。</p>
<p>这样当B接收到A的信息后，获取信息内容的步骤如下：<br>1、B用自己的私钥（PRI_B）解密A用B的公钥（PUB_B）加密的内容；<br>2、得到解密后的明文后用A的公钥（PUB_A）解签A用A自己的私钥（PRI_A）的签名。</p>
<p>从而整个过程就保证了开始说的端到端的唯一确认。<br>A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的。<br>A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取。</p>
<p>这个过程可以这么个故事来概括:<br>B的银行卡落到A的家里了，A要给B邮寄银行卡，提前和B说了我要给你寄银行卡(B拿到A的公钥)，<br>A在寄银行卡的时候要求快递员在B收到东西时说出是谁寄的(A用自己的私钥进行签名)，只有说对了才给B(B用A的公钥验证签名)。</p>
<p>这张银行卡对于快递员来说是加密的(快递员既不知道银行卡是谁的，也不知道银行卡密码)，但是对于A来说，A知道银行卡是谁的(相当于B的公钥)，而对于B来说，B有银行卡的密码(B的私钥)。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[no rule to process file 'xxx.h' of type sourcecode.c.h for architecture armv7]]></title>
      <url>/2017/11/02/29/</url>
      <content type="html"><![CDATA[<p>Xcode编译提示：[WARN]warning: no rule to process file ‘xxx.h’ of type sourcecode.c.h for architecture armv7<br><a id="more"></a><br>iOS开发中，Xcode编译出现如下警告提示： [WARN]warning: no rule to process file xxx.h’ of type sourcecode.c.h for architecture armv7</p>
<p>这是因为检查到有.h文件在编译列表中了。<br>所以只要在列表中去掉就可以。<br>点击你的xcode项目文件，然后点击『Build Phases』，确保在『Compile Sources』中没有.h文件。</p>
]]></content>
      
        
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度探索TLD的C++源码]]></title>
      <url>/2017/11/01/32/</url>
      <content type="html"><![CDATA[<p>首先提一点，我用的环境是VS2015+OpenCV3.2，在不同的环境下配制方法有出入，请对号入座。<br><a id="more"></a></p>
<h3 id="网上的TLD有两个版本，一个是Zdenek-Kalal自己使用matlab-vs混合编程实现的，另外一个是-arthurv利用c-和opencv实现的。"><a href="#网上的TLD有两个版本，一个是Zdenek-Kalal自己使用matlab-vs混合编程实现的，另外一个是-arthurv利用c-和opencv实现的。" class="headerlink" title="网上的TLD有两个版本，一个是Zdenek Kalal自己使用matlab+vs混合编程实现的，另外一个是 arthurv利用c++和opencv实现的。"></a>网上的TLD有两个版本，一个是Zdenek Kalal自己使用matlab+vs混合编程实现的，另外一个是 arthurv利用c++和opencv实现的。</h3><p>1.1、我利用的是arthurv版本的Tracking-Learning-Detection<br>连接：<a href="https://github.com/alantrrs/OpenTLD" target="_blank" rel="noopener">https://github.com/alantrrs/OpenTLD</a></p>
<p>1.2、下载得到的C++代码如下所示<br>其中：<br>datasets是一些视频数据；<br>doc是程序的流程图进行说明；<br>include是头文件；<br>src是源文件；<br>parameters.yml是参数文件；<br>readme是程序运行说明。</p>
<h3 id="我们只要用到datasets、include、src、parameters-yml"><a href="#我们只要用到datasets、include、src、parameters-yml" class="headerlink" title="我们只要用到datasets、include、src、parameters.yml;"></a>我们只要用到datasets、include、src、parameters.yml;</h3><p>下面讲述如何在VS2015下创建工程；</p>
<p>2.1、创建一个空的solution(没有预编译的控制台程序)</p>
<p>2.2、首先将include中的文件拷贝放到src的文件夹中；然后将src、datasets、parameters.yml放到solution的工程目录下，如下所示：<br><img src="/2017/11/01/32/20171101102925801.jpeg"></p>
<p>2.3、编译项目，此时会冒出错误，下面为解决方法：<br>a．首先将头文件包含错误的全部由include<tld.h> 改成 include “TLD.h”;其他的头文件包含以此类推；解释一下：&lt;&gt;的引用是在整个文件目录，包括系统环境变量库里找，而“”是在当前文件目录里找。</tld.h></p>
<p>b．关于在TLD.h中包含头文件#include <opencv2 legacy="" legacy.hpp="">的问题；由于原作者是在opencv2.4的版本下进行的编译，由于opencv3的各种版本相对于opencv2的版本已经改变了很多内容，openTLD跟踪算法所依赖的一些函数在opencv3中已经消失了，最重要的一点就是到了Opencv3.2中已经不包括legacy.hpp库，所以我们需要添加PatchGenerator.h和PatchGenerator.cpp两个文件，并在对应的地方include头文件（对应的删掉legacy.hpp），才能做到不缺失文件。<br>两个文件参考地址：<a href="http://blog.csdn.net/j10527/article/details/51305087" target="_blank" rel="noopener">http://blog.csdn.net/j10527/article/details/51305087</a></opencv2></p>
<p>c．LKTracker.cpp中：需要添加如下几行，以防止调用不到定义函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/11/01/32/20171101103053722.jpeg">
<p>d．在TLD.h中，由于C++中的数组不能为变量，所以需要做如下修改：<br>将const int c = dbb.size();改为：<br>const int c = 100; 即定义为常数<br><img src="/2017/11/01/32/20171101103219250.jpeg"></p>
<p>e.对应的，TLD::clusterBB函数中，vs不支持动态数组分配。其中的动态数组需要改成指针和动态分配内存，并且需要在结尾处释放内存。<br><img src="/2017/11/01/32/20171101103256523.jpeg"><br><img src="/2017/11/01/32/20171101103314568.jpeg"></p>
<p>f．round、ceil和floor可能会出现错误，原因是round和ceil内部传入的参数必须是double或者float型，所以将这三个函数里面的数据改为float型，具体做法就是里面的整数后面加上小数点，比如2，就改为2.0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int stepx = ceil(double((bb.width - 2.0 * margin_h)/max_pts));</span><br><span class="line">int stepy = ceil(double((bb.height - 2.0 * margin_v)/max_pts));</span><br></pre></td></tr></table></figure></p>
<img src="/2017/11/01/32/20171101103353732.jpeg">
<p>g.打开run_tld.cpp 将其中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (strcmp(argv[i],&quot;-tl&quot;)==0)&#123;</span><br><span class="line">    tl = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (strcmp(argv[i],&quot;-no_tl&quot;)==0)&#123;</span><br><span class="line">    tl = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/11/01/32/20171101103537148.jpeg">
<p>对于下图这个修改，我是试过的，但是会出现如下问题：所以tl=false没有变，具体是为什么会出问题我还没有查明。<br><img src="/2017/11/01/32/20171101103600584.jpeg"><br><img src="/2017/11/01/32/20171101103624414.png"><br><img src="/2017/11/01/32/20171101103653092.jpeg"></p>
<p>h．最后，由于这个项目是里面是先产生一个可执行文件在cmd下来执行，并且需要采用cmd命令预先调用parameters.yml中的初始化参数。这样不方便我们调试；因此我们要修改程序一开始的参数解析函数：<br><img src="/2017/11/01/32/20171101103731426.jpeg"></p>
<p>2.4 release完成后，在生成的文件夹中直接打开EXE文件，完美运行（仅对摄像头，测试视频未调用）<br><img src="/2017/11/01/32/20171101103830769.jpeg"></p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift4.0 strtoul、strtod、strtof、strtol等字符串函数的改变]]></title>
      <url>/2017/10/26/24/</url>
      <content type="html"><![CDATA[<p>在新的iOS 11的SDK中，这几个函数参数类型发生了改变<br><a id="more"></a><br>在新的iOS 11的SDK中，这几个函数参数类型发生了改变，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public func strtod(_: UnsafePointer&lt;Int8&gt;!, _: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!) -&gt; Double</span><br><span class="line"></span><br><span class="line">public func strtof(_: UnsafePointer&lt;Int8&gt;!, _: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!) -&gt; Float</span><br><span class="line"></span><br><span class="line">public func strtol(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; Int</span><br><span class="line"></span><br><span class="line">public func strtoll(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; Int64</span><br><span class="line"></span><br><span class="line">/* !__DARWIN_NO_LONG_LONG */</span><br><span class="line">public func strtoul(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; UInt</span><br><span class="line"></span><br><span class="line">public func strtoull(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; UInt64</span><br></pre></td></tr></table></figure></p>
<p>从原来可以直接传的char*变成了一个UnsafePointer<int8>。那么我们用到函数的地方也要改变一下，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s = hex[hex.characters.index(hex.startIndex, offsetBy: start)..&lt;hex.characters.index(hex.startIndex, offsetBy: end)]</span><br><span class="line">return CGFloat(s.withCString&#123;strtoul($0, nil, 16)&#125;)</span><br></pre></td></tr></table></figure></int8></p>
<p>这里的s是一个String类型，他有一个withCString方法。利用这个方法可以将字符串中的字符转换成UnsafePointer<int8>类型。</int8></p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决NSTimer在UITableView滑动中暂停问题]]></title>
      <url>/2017/09/04/30/</url>
      <content type="html"><![CDATA[<p>最近在研究动画特效。发现将NSTimer动画添加到tableVIew上的时候会遇见动画暂停的问题，其实是动画的计时器停止了，经过研究找到了解决方法， 和大家分享一下。<br><a id="more"></a><br>当你使用下面这个方法创建NSTimer的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class func scheduledTimer(timeInterval ti: TimeInterval, target aTarget: Any, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) -&gt; Timer</span><br></pre></td></tr></table></figure></p>
<p>在tableview滑动时timer就是显示暂停，原因是timer的这个简便构造方法把timer加入了NSRunLoopDefaultMode上，而tableview在滑动时只会处理UITrackingRunLoopMode，也就是说当前的RunLoop并没有功夫处理timer事件。</p>
<p>解决的方法是将timer绑定到NSRunLoopCommonModes上，通过以下方法构造timer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(timeInterval ti: TimeInterval, target aTarget: Any, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool)</span><br></pre></td></tr></table></figure></p>
<p>这样timer在tableview滑动中就不会暂停了。</p>
<p>当然这样做也不是100%能解决问题，有时timer计时不准确。具体的解决方法可以参考这个：<br><a href="http://blog.csdn.net/martin_liang/article/details/40783057" target="_blank" rel="noopener">http://blog.csdn.net/martin_liang/article/details/40783057</a><br>但是像我这样做动画、对时间精确度要求不高的，倒是可以用这个方法解决问题。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MATLAB2016b 中运行color_tracker出错]]></title>
      <url>/2017/08/28/33/</url>
      <content type="html"><![CDATA[<p>最近在研究视觉追踪算法，看到了一篇Adaptive Color Attributes for Real-Time Visual Tracking，俗称CN的视觉追踪算法，从官网下载程序之后，在公司的电脑上（MATLAB2014a）完美运行，但是在我的电脑MATLAB2016b上却运行出错。<br><a id="more"></a><br>最近在研究视觉追踪算法，看到了一篇Adaptive Color Attributes for Real-Time Visual Tracking，俗称CN的视觉追踪算法，从官网下载程序之后，在公司的电脑上（MATLAB2014a）完美运行，但是在我的电脑MATLAB2016b上却运行出错，具体错误如下：<br><img src="/2017/08/28/33/20170828151236654.jpeg"></p>
<p>报错提示我Number值必须是双精度标量或空矩阵！！！<br>于是我在网上寻找相关的资料，发现并没有与之相关的错误出现（根本就没有figure中number的用法！！！），但是在寻找中我发现了某个网站贴出了详细的figure应用格式表：<br>在仔细查看后发现了如下一个应用：<br><img src="/2017/08/28/33/20170828151435869.jpeg"></p>
<p>注意这个缺省值，不就是figure所需要的“空矩阵”吗？，于是我将对应出错的那一段改成了如下形式：把number用userdata进行了替换：<br><img src="/2017/08/28/33/20170828151637804.jpeg"><br>再次运行，完美解决。<br><img src="/2017/08/28/33/20170828151654822.jpeg"></p>
<p>ps：虽然自己找到了可以解决运行的方法，但是可能会有点“野狐禅”的感觉，因为自己对matlab的应用还不够熟练，以后还是要多多学习，不过还是邓爷爷说得好，不管黑猫白猫，能抓到老鼠的就是好猫，所以只要能解决问题就行了~</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(五) ---- 挑战AppStore审核]]></title>
      <url>/2017/05/02/20/</url>
      <content type="html"><![CDATA[<p>当开发一个应用或评估其面对的威胁时，需要将用户设备上的其他应用考虑进来。设备上任何恶意的第三方应用程序都能通过IPC机制与其他应用交互，也能窃取用户的私人信息。AppStore的应用程序审查是对抗这些恶意程序最有力的武器。<br><a id="more"></a><br>当开发一个应用或评估其面对的威胁时，需要将用户设备上的其他应用考虑进来。设备上任何恶意的第三方应用程序都能通过IPC机制与其他应用交互，也能窃取用户的私人信息。AppStore的应用程序审查是对抗这些恶意程序最有力的武器。</p>
<p>苹果公司没有公开披露他们的审查技术，而该技术主要用来检查应用能否满足AppStore的上架要求。可以确定的是，苹果使用了二进制分析和动态测试技术。这一过程可以将绝大部分带有明显恶意的应用拒之门外，也阻止了一些苹果不喜欢的应用上架(比如多种通信应用，色情或者重口味的应用)。</p>
<p>尽管苹果公司付出了很大努力来确保用户可以用到安全和高质量的应用，但事实证明，一个中等水平的攻击者完全有能力伪装一个动态代码更新应用，让他通过苹果商店的审查。主要有以下几个方式。</p>
<h2 id="WebKit桥接："><a href="#WebKit桥接：" class="headerlink" title="WebKit桥接："></a>WebKit桥接：</h2><p>基于WebKit桥接，可以通过JavaScript使用一些iOS的原生API，比如获取用户位置和使用媒体服务。PhoneGap就是一个典型的框架，以及最近很火的JSPatch。这种方式可以提供能多有用的功能，但使用它们也意味着应用程序的许多逻辑要写成JavaScript，因此不需要打包到应用中。举个例子，一个开发者可以使用JavaScript实现一个常规的打开文件功能，然后在应用审核期间不做任何的恶意操作。一旦审核通过，开发者可以修改设备的JavaScript，从而读取设备上那些本应该是禁区的数据。当然，现在这种热更新已经被苹果明令禁止了。所有使用了热更新框架的开发者都收到了苹果发的警告邮件，限定以后的版本不需使用热更新，不然可能会导致应用程序下架。但是对于Web应用来说，却没有什么明确的限制。还有一些使用了React Native框架的应用程序也没有收到警告，当然，这也不意味着以后苹果不会封杀它，毕竟他的创造者Facebook也只是在一些小应用上使用了这个框架。</p>
<h2 id="动态修复："><a href="#动态修复：" class="headerlink" title="动态修复："></a>动态修复：</h2><p>通常来说，如果一段原生代码没有经过苹果发布的密钥签名认证，应用程序则无法运行它。如果苹果的签名验证逻辑中存在bug或漏洞，那么可能就会允许下载和执行原生代码。iOS有一个特性，前面的文章提到过，可以让程序分配一段没有NX保护的内存区块，该区块可读可写，甚至可以执行，里面运行的代码也不需要经过签名验证。这一机制被苹果用在了Safari的JIT编辑器上，以便实现一些功能，但是这就给了攻击者可趁之机。毕竟有代码的地方就可能出现漏洞，这样第三方应用程序就可以执行相同的把戏。最著名的例子就是Charlie Miller的破解程序，他破解了这个特性。这就意味着原生代码不需要签名认证就可以下载并执行。Miller向AppStore提交了一个股票代码查询应用InstaStock来演示这一过程。在应用审查期间，该应用安分守己，不进行任何恶意或者异常操作。但是一旦通过审核，Miller可以远程遥控该应用程序下载新的，未经签名的代码并执行，整个过程毫无阻碍。当然，现在这个漏洞已经被补上了，但是他却为我们如何骗过审核提供了思路。</p>
<h2 id="故意植入不安全代码："><a href="#故意植入不安全代码：" class="headerlink" title="故意植入不安全代码："></a>故意植入不安全代码：</h2><p>这个绕过AppStore审查的方法很有趣，它会让你的应用变得更加脆弱，很容易受到远程攻击。乔治亚理工学院曾开发过一款用来概念演示的应用Jekyll，他主要用来演示应用内核的缓冲区溢出。恶意代码被打包在应用程序自身之中以便可以顺利获得签名，同样在审查时不进行任何恶意操作，不去调用这些代码。一旦获准上架，开发者能够利用缓冲区溢出的漏洞改变应用程序的控制流，使其导向隐藏的恶意代码。这些代码能够使用苹果的私有框架，进而操控设备的蓝牙、短信甚至其他模块。</p>
<h2 id="内嵌解释器："><a href="#内嵌解释器：" class="headerlink" title="内嵌解释器："></a>内嵌解释器：</h2><p>过去几年，苹果在这方面的政策已经发生了改变，有许多产品(主要是游戏)会使用一个内嵌的Lua解释器来执行大部分的内在逻辑。当然了，过了这么多年，以内嵌解释器为媒介的恶意行为还没有见诸报端，毕竟相对于JavaScript直接调用原生代码来说，Lua解释器对于系统的原声API的操控还是十分受限的，你只能在一个安全的API范围内进行操作。但是，恶意应用可以通过一个类似的解释器来动态下载代码，并在内存中执行。当然，在AppStore的审核中这些恶意代码还是会隐藏自己。通过此方法我们能增加一个新的功能，行为不端的开发者也能较为便利的添加一个恶意功能。</p>
<p>其实AppStore的审核只能清除那些简单的恶意程序，但是恶意程序的确可以从审查人员的眼皮子底下溜走。时刻记住这一点，并在你的应用程序中用代码做好防御，不能假定操作系统中的其他程序都是善意的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(四) ---- 防御代码漏洞和越狱检测]]></title>
      <url>/2017/05/01/19/</url>
      <content type="html"><![CDATA[<p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化(ASLR)和XN bit(eXecute Never的缩写，标记该段内存区域不包含可执行代码)。<br><a id="more"></a></p>
<h2 id="防御代码漏洞："><a href="#防御代码漏洞：" class="headerlink" title="防御代码漏洞："></a>防御代码漏洞：</h2><p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化(ASLR)和XN bit(eXecute Never的缩写，标记该段内存区域不包含可执行代码)。每次执行程序时，ASLR都会随机分配内存、数据、堆和栈的内存位置。共享库需要在多个进程中使用，因此共享库的内存地址只在每次系统重启时随机设置，而不是每次执行程序时。函数和哭的内存地址很难预测，这就预防了缓冲区溢出攻击(return-to-libc)，这种攻击依赖于基本库函数的已知地址。</p>
<p>XN bit一般对于非ARM平台的NX(No-eXecute) bit，允许操作系统将某段内存标记为不可执行，这是由CPU来控制的，学过计算机组成原理的同学都知道，每个CPU指令都有专门的地址存放。在iOS中，这个机制默认应用在程序的堆和栈上。这就意味着，哪怕攻击者可以将恶意代码注入程序的堆和栈，他们也无法重定向应用程序来执行攻击代码。</p>
<p>每个程序都有一段既能写又能执行的内存，前提是他必须经过苹果的官方签名授权系统的签名。Safari中的JavaScript即时(JIT)编译器会用到这段内存。你平时在应用程序中经常使用的WebView并不具备访问相同功能的权利，这样就可以避免代码执行攻击。苹果一直禁止第三方的JIT，好处是更安全，而坏处也很明显，就是iOS平台上的Chrome等其他浏览器无法做到像Safari那样好用，因为他们只能使用WebView。</p>
<h2 id="越狱检测："><a href="#越狱检测：" class="headerlink" title="越狱检测："></a>越狱检测：</h2><p>越狱的本质就是通过一系列步骤来禁用掉苹果的签名机制，从而允许设备运行未经苹果官方审核的应用。越狱还允许你使用那一些便利的开发和测试工具，当然这些工具永远不会通过AppStore的审核。越狱的用户有能力做正常情况下其他iOS用户做不到的事。越狱还有一个至关重要的能力，就是黑箱测试应用程序。</p>
<p>和大多数人想的不一样，越狱不一定要禁用掉iOS的沙盒机制，他只是允许你在沙盒外安装应用程序。安装在移动用户主目录下的应用程序(即从AppStore下载的)仍然受到沙盒的限制。第三方的iOS应用程序需要安装在越狱设备中权限更高的/Applications目录下，与苹果股票应用安装在一起(就是那些你删不掉的系统应用).</p>
<p>越狱检测很早就有，不过没啥用。他的目的是检测设备是否存在不受信任、未经签名的第三方应用程序，从而判断设备是否处在高风险环境中。公平地说，第三方程序库中不乏恶意软件和行为不端的应用程序(像XX万能钥匙。。大家应该很清楚为什么能直接连上别人家的网)，但总体来说，越狱检测不值得你浪费时间去做，因为他无法阻止一个坚定地攻击者。</p>
<p>有一段时间苹果官方推出过越狱检测的API，但很快就在后续的iOS版本中删掉了。具体原因众说纷纭，但是即使没有此API，开发者也找到了一些越狱检测的方法，大家知道就行了，没必要在这里费太多精力。</p>
<p>1.创建一个新进程，例如调用fork()、vfork()、popen()等方法。这是明显会被沙盒机制所禁止的事情。当然，大部分越狱系统上沙河依然是有效的，所以这种检测毫无意义。无论你设备是否越狱，总是可以从AppStore下载应用的。</p>
<p>2.读取沙盒外部的文件，开发者通常想要尝试访问一些二进制代码，这些二进制代码通常对应于ssh、bash，还有一些位于Cydia.app目录和Cydia经常使用的apt仓库等位置。但是这些检测很容易被绕过，并且Xcon6之类的工具也能帮助用户绕过这些自动检查。</p>
<p>3.不要使用太直白的方法名，比如isJailbroken，否则攻击者可以轻易定位并禁掉越狱检测。根据渗透测试同事多年的工作经验来看，像那种不改默认密码或者密码一猜就中的服务器数据库，简直是弱智写的。。还有这些很容易知道是做什么用函数。</p>
<p>还有些更复杂的技术，比如苹果的iBooks应用会尝试运行随着应用打包的未签名代码，而精明的开发者同样会尝试使用_dyld_image_count()和_dyld_get_image_name()来检查载入动态库(dynamiclibrartes, dylibs)的数量和他们的名字，并使用_dyld_get_image_header()来检查他们在内存中的位置。想要绕过这些检测通常需要给应用程序打一个二进制补丁。</p>
<p>想必读者都注意到了，我不是很喜欢搞越狱检测。就像二进制混淆技术和DRM一样，越狱检测被攻击者绕过时只会显得你更加愚蠢。毕竟对于攻击者来说，一些粗略的越狱检测只能拖慢自己前进的脚步几个小时而已。你要知道，对手的爱好就是破解程序，他们通常有大把的时间用来暴力破解，几个小时的时间对于他们而言并没有什么实际意义。我曾经看别人开发过一个二进制混淆程序，然后找渗透测试的同事帮忙测试，仅仅一个工作日就被搞清了算法。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(三) ---- 数据保护和全盘加密]]></title>
      <url>/2017/04/09/18/</url>
      <content type="html"><![CDATA[<p>iOS提供全盘加密，还为开发者提供了数据保护的API，用于进一步保护自己的文件。这两个机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄露。<br><a id="more"></a><br>iOS提供全盘加密，还为开发者提供了数据保护的API，用于进一步保护自己的文件。这两个机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄露。</p>
<p>全盘加密其实解决了一个历史问题：用户数据会随设备一起被窃取。在笔记本或者台式机的环境下，如果想窃取数据，要么需要将硬盘转移到一个新机器上，要么引导一个操作系统来读取设备中的数据。文件系统加密并不能防止从一个正在运行的设备上窃取数据的行为。如果一个应用可以从磁盘中读取任意一个文件，那么文件系统加密其实是没有任何作用的，因为对于系统内核来说，任何尝试读取这些文件的进程都是透明解密的。相比于那些读文件的调用行为，文件系统加密工作在更底层。一旦攻击者攻破了系统验证，那他就能无障碍的读取任何文件。</p>
<p>iOS设备通常是全天运行设计，他们的内部存储器不容易被拆卸。如果一个攻击者想要不通过验证就从设备中读取敏感信息，他必须把设备完全拆解，然后将闪存存储器连接到一个自定义的接口上来读取数据。不过从设备中获取数据有更为简单的方法，而不用拆手机(毕竟拆手机这种事情一般人也做不来)：代码执行漏洞、越狱等。</p>
<p>iOS的全盘文件系统加密对于安全删除文件和远程设备擦除。传统的安全擦除文件的方法不适用于iOS设备，因为iOS设备主要使用固态硬盘(SSD)作为存储。固态硬盘的原理这里不再赘述，相信大家也都了解一些。SSD采用了减少磨损的机制，因此覆盖文件的操作无法保证真正覆盖硬盘中的旧数据。但是这不意味着我们对此束手无策，解决方法是确保文件被一个安全位置上的密钥加密，这样请求销毁数据的时候，可以直接丢弃密钥。iOS设备中使用的加密密钥是分层级的，只需要简单地丢弃一个加密密钥就能彻底销毁底层的数据，甚至是销毁整个文件系统(不得不说当时设计这个规则的人是真厉害)。</p>
<h2 id="加密密钥的层级："><a href="#加密密钥的层级：" class="headerlink" title="加密密钥的层级："></a>加密密钥的层级：</h2><p>分层级的加密密钥其实是说用密钥来加密其他密钥，这样苹果就能更精确的控制数据什么时候可用。</p>
<p>它们的层级关系是这样的：</p>
<p>设备密钥+用户密码-&gt;层级密钥</p>
<p>设备密钥-&gt;文件系统密钥-&gt;层级密钥</p>
<p>层级密钥-&gt;文件密钥</p>
<p>文件密钥(File Key)针对每个文件单独生成，存储在文件的元数据中。不同级别的文件需要使用不同强度的加密密钥。</p>
<p>层级密钥(Class Key)的作用是专门为那些特殊数据提供不同级别的保护。在早先的iOS版本中，默认的保护等级是NSFileProtectionNone；但是从iOS5开始，默认的保护等级变成了NSFileProtectionCompleteUntilFirstUserAuthentication。</p>
<p>文件系统密钥(Filesystem Key)是一种全局加密密钥，当元数据被层级密钥加密后，我们使用文件系统密钥来加密涉及文件安全的元数据。</p>
<p>设备密钥(Device Key)通常被称为UID密钥，每台设备唯一，只能通过硬件的AES引擎访问，操作系统无法直接获取。这是系统的主密钥，他用来加密文件系统密钥和层级密钥。如果用户启用了用户密码(User Passcode)，他将与设备密钥结合起来加密层级密钥。</p>
<p>一旦设置了用户密码，这个密钥等级也允许开发者自己决定本地存储的数据该如何被保护，包括：在设备锁定时能否被访问、数据能否备份到其它设备等。</p>
<h2 id="钥匙串API"><a href="#钥匙串API" class="headerlink" title="钥匙串API"></a>钥匙串API</h2><p>iOS提供了钥匙串API来存储少量机密信息。开发者可以用来存储密码、机密密钥以及那些不能被其他应用访问的敏感信息。调用钥匙串API主要通过securityd守护进程来完成，即从SQLite数据库中提取数据。开发者可以指定在什么情况下允许应用读取密钥，这和数据保护的API类似。</p>
<h2 id="数据保护API"><a href="#数据保护API" class="headerlink" title="数据保护API"></a>数据保护API</h2><p>数据保护API利用文件系统加密、钥匙串和用户密码，提供了一个额外的针对文件的保护层，开发者可以根据需求调用。这限制了某些进程在系统层面读取文件。这个API最常用的场景就是当设备锁定时确保数据不可用。</p>
<p>数据保护的强度在很大程度上取决于iOS的版本。随着版本更新，默认的数据保护等级会发生变化。在新创建的iOS应用程序中，数据保护默认对所有应用程序开启，这种状态在启动设备后的第一次解锁前都生效。你可以在项目的Capabilities里找到Data Protection这个选项。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你真的了解位运算？用了这个运算符，算法的时间复杂度竟然降了一个数量级！]]></title>
      <url>/2017/04/06/14/</url>
      <content type="html"><![CDATA[<p>其实这个运算符很容易被人忽略，他就是C语言中的位异或运算符^<br>位运算符家族中，最常用的，莫过于异或运算符。<br><a id="more"></a><br>其实这个运算符很容易被人忽略，他就是C语言中的位异或运算符^<br>位运算符家族中，最常用的，莫过于异或运算符。</p>
<p>我们先看异或运算符的定义： 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。<br>即：0^0=0， 1^0=1， 0^1=1， 1^1=0</p>
<p>例如：10100001^00010001=10110000<br>0^0=0,0^1=1    可理解为： 0异或任何数，其结果=任何数<br>1^0=1,1^1=0    可理解为： 1异或任何数，其结果=任何数取反<br>任何数异或自己，等于把自己置0</p>
<p>通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a，b的值，可通过下列语句实现：<br>a=10100001,   b=00000110<br>a=a^b； 　　//a=10100111<br>b=b^a； 　　//b=10100001<br>a=a^b； 　　//a=00000110</p>
<p>异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.</p>
<p>利用他的特点，我们可以解决一个常见的问题：<br>Single Number: 整数型数组中，每个元素均出现两次，除了一个元素例外，如何找出这个元素？能否设计一个线性时间的算法，且不需要额外的存储空间？</p>
<p>其实O(n)的算法不容易一下子想到，先说说常规的解决思路，有如下两种：<br>1、对元素的出现次数进行统计，可进行n*n循环，判断元素是否只出现了一次。这样时间复杂度为O(n^2), 不需要额外空间。<br>2、先对元素进行排序，然后进行相邻两元素的对比，如a1和a2对比，a3和a4对比，如果不同，则前一个元素(a1、a3)就是所要查找的元素。<br>这两种解法的时间复杂度都比O(n)更高。但是，如果你运用了异或运算符的特点，那么这个问题就很容易解决了，算法复杂度为O(n)，且不需要额外空间，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(int A[], int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result ^=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Xcode单元测试，你必须知道的18个知识]]></title>
      <url>/2017/04/06/31/</url>
      <content type="html"><![CDATA[<p>关于Xcode的单元测试，有些方法你是必须知道的。<br><a id="more"></a></p>
<ol>
<li><p>XCTFail(format…) 生成一个失败的测试；</p>
</li>
<li><p>XCTAssertNil(a1, format…)为空判断，a1为空时通过，反之不通过；</p>
</li>
<li><p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p>
</li>
<li><p>XCTAssert(expression, format…)当expression求值为TRUE时通过；</p>
</li>
<li><p>XCTAssertTrue(expression, format…)当expression求值为TRUE时通过；</p>
</li>
<li><p>XCTAssertFalse(expression, format…)当expression求值为False时通过；</p>
</li>
<li><p>XCTAssertEqualObjects(a1, a2, format…)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p>
</li>
<li><p>XCTAssertNotEqualObjects(a1, a2, format…)判断不等，[a1 isEqual:a2]值为False时通过；</p>
</li>
<li><p>XCTAssertEqual(a1, a2, format…)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p>
</li>
<li><p>XCTAssertNotEqual(a1, a2, format…)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p>
</li>
<li><p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p>
</li>
<li><p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p>
</li>
<li><p>XCTAssertThrows(expression, format…)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p>
</li>
<li><p>XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p>
</li>
<li><p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>
</li>
<li><p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p>
</li>
<li><p>XCTAssertNoThrowSpecific(expression, specificException, format…)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>
</li>
<li><p>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>
</li>
</ol>
<p>特别注意下XCTAssertEqualObjects和XCTAssertEqual。</p>
<p>XCTAssertEqualObjects(a1, a2, format…)的判断条件是[a1 isEqual:a2]是否返回一个YES。</p>
<p>XCTAssertEqual(a1, a2, format…)的判断条件是a1 == a2是否返回一个YES。</p>
<p>对于后者，如果a1和a2都是基本数据类型变量，那么只有a1 == a2才会返回YES。</p>
]]></content>
      
        
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(二) ---- 沙盒机制]]></title>
      <url>/2017/03/26/17/</url>
      <content type="html"><![CDATA[<p>苹果的沙盒机制想必大家都听过，并且都会称赞这是iOS做的比安卓系统好的一个重要因素，沙盒机制让iOS更为安全。<br><a id="more"></a><br>苹果的沙盒机制想必大家都听过，并且都会称赞这是iOS做的比安卓系统好的一个重要因素，沙盒机制让iOS更为安全。</p>
<p>沙盒机制历史上被称作安全带，是一种基于FreeBSD系统(是一种类UNIX操作系统，是由经过BSD、386BSD和4.4BSD发展而来的Unix的一个重要分支)TrustedBSD框架的强制访问控制(MAC)机制，他的主要推动者是罗伯特沃森。这里我只是简单介绍一下，详细的信息以及介绍可以看这里<a href="http://shouce.jb51.net/freebsd-arch-handbook/mac.html" target="_blank" rel="noopener">TrustedBSD MAC框架介绍</a>，这份文档写得十分详尽，感兴趣的读者可以看看。</p>
<p>言归正题，沙盒机制采用一种类似于Lisp的配置语言来描述那些资源系统可以访问，哪些禁止访问。这些资源包括文件、系统服务、网络连接、内存资源等。MAC机制不同于传统的访问控制机制(比如自主访问控制DAC)，他不允许主体(比如用户进程)操作对象(文件、套接字等)。DAC最常见的形式就是Unix系统上的用户、组和其它权限，所有这些都可以被授予读、写或执行的权限。在DAC系统中，用户如果拥有了一个对象的所有权，也就拥有了该对象的修改权限。例如，你有一个文件，你可以将其设置为全局可读或可写，这显然是破坏了访问机制。</p>
<p>MAC是一个广义的术语，在沙盒中意味着应用程序被关进了一个虚拟的容器。该容器遵循一系列的特定规则，即哪些系统资源可以被访问，比如网络资源、文件读写、进程克隆等。在OS X中你可以部分控制应用程序的沙盒功能，但是在iOS中，所有的第三方应用都要遵循唯一的限制策略。</p>
<p>在文件访问方面，一般只能访问应用程序的包目录。应用程序可以读写存储在该位置的文件。不过这一基本规则存在少许的例外。例如，在某些iOS版本中，图片一般存储在目录/private/var/mobile/Media/Photos/ 中。尽管它在应用程序的包目录之外，但第三方应用还是可以直接访问，这样应用程序就无需获得用户许可就能访问系统相册，在之前的iOS版本中，如果想要阻止应用程序滥用权力，就只能将希望寄托在苹果审核的身上。但是在最新的iOS10系统里，所有访问操作都必须经过授权，而且在应用开发时必须将要使用到的权限(如相册、相机、麦克风)写入plist文件中，不然应用程序在使用到这些API时会崩溃，而且审核应用时一定会被拒绝。</p>
<p>安卓的访问控制机制与MAC不同。安卓实现了一个更加传统的DAC模型，应用程序都有自己的用户ID和属于该ID的文件夹，其权限管理严格按照传统的Unix文件权限管理运作。虽然两种机制工作起来都没有问题，但是MAC的扩展性总体来说还是要更强一些。例如，除了应用目录隔离，MAC机制还可以限制网络访问或守护系统进程的操作。</p>
<h2 id="术语解析-详情请点文中链接查看-："><a href="#术语解析-详情请点文中链接查看-：" class="headerlink" title="术语解析(详情请点文中链接查看)："></a>术语解析(详情请点文中链接查看)：</h2><p>FreeBSD： 以一个内核安全扩展性框架(TrustedBSD MAC 框架)的方式，为若干强制访问控制策略(也称“集权式访问控制策略”) 提供试验性支持。MAC 框架是一个插入式的访问控制框架，允许新的安全策略更方便地融入内核：安全策略可以静态链入内核,也可以 在引导时加载,甚至在运行时动态加载。该框架所提供的标准化接口,使得运行在其上的安全策略模块能对系统对象的安全属性进行诸如标记等一系列操作。 MAC 框架的存在，简化了这些操作在策略模块中的实现，从而显著降低了新安全策略模块的开发难度。</p>
<p>TrustedBSD：MAC 框架提供的机制,允许在其上运行的内核模块在内核编译或者运行时，对内核的访问控制模型进行扩展。 新的系统安全策略作为一个内核模块实现,并被链接到内核中；如果系统中同时存在多个安全策略模块，则它们的决策结果将以某种确定的方式组合。 为了给简化新安全策略的开发，MAC 向上提供了大量用于访问控制的基础设施，特别是对临时的或者持久的、策略无关的对象安全标记的支持。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(一) ---- 安全启动]]></title>
      <url>/2017/03/26/16/</url>
      <content type="html"><![CDATA[<p>就目前情况来说，AppStore确实成功的将很多恶意软件拒之门外，但是对于开发者来说，应用程序的审查就是一个黑箱操作。苹果公司对应用的审查不会对外公开，所以你无法搞清楚他们是如何揪出你应用中那些不能使用的API。大部分时候你搞不清楚什么功能允许使用，什么功能禁止使用。但是苹果提供了正式的指导手册，但是很多遵循了执导的应用同样会被拒绝。<br><a id="more"></a><br>就目前情况来说，AppStore确实成功的将很多恶意软件拒之门外，但是对于开发者来说，应用程序的审查就是一个黑箱操作。苹果公司对应用的审查不会对外公开，所以你无法搞清楚他们是如何揪出你应用中那些不能使用的API。大部分时候你搞不清楚什么功能允许使用，什么功能禁止使用。但是苹果提供了正式的<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="noopener">指导手册</a>，但是很多遵循了执导的应用同样会被拒绝。</p>
<p>当然，什么是恶意程序是由苹果来定义的，苹果使用AppStore来控制或限制iOS平台上的应用程序的功能，这就意味着如果要实现某个特定的功能，唯一的手段就是要将设备越狱或者骗过应用商店的审查。比如通过某些特殊的操作(摇动手机XX次，出现一个控制按钮)开启隐藏功能。</p>
<p>官方的应用审查永远无法抓到那些钻空子的恶意软件，所以需要另外一套高效的机制来阻止恶意程序破坏操作系统的安全。在接下来的时间里，我会不定期的更新博客，介绍iOS的一些基本安全组件是如何阻止恶意攻击和保护数据的。</p>
<h2 id="首先介绍iOS的安全启动机制："><a href="#首先介绍iOS的安全启动机制：" class="headerlink" title="首先介绍iOS的安全启动机制："></a>首先介绍iOS的安全启动机制：</h2><p>当启动一台iOS设备时，系统首先会从只读的ROM中读取初始化指令，也就是系统的引导程序(事实上所有的操作系统启动时都要经过这一步，只是过程略有不同)。这个引导ROM包含苹果官方权威认证的公钥，他会验证底层启动加载器(LLB)的签名，一旦通过验证后就启动系统。LLB会所一些基础工作，然后验证第二级引导程序iBoot。iBoot启动后，设备就可以进入恢复模式或启动内核。在iBoot验证完内核签名的合法性之后，整个启动程序开始步入正轨：加载驱动程序、检测设备、启动系统守护进程。</p>
<p>这个信任链会确保所有的系统组件都有苹果官方写入、签名、分发，不能来自第三方机构，特别是那些恶意攻击者或者是给设备越狱的黑客。应用程序启动时也会用信任链去审查签名。所有的应用都必须直接或间接地由苹果签名(这就是为什么要申请开发者账号，生成开发和发布证书以及申请App ID的原因。很多开发者也经历过安装测试APP时提示你信任开发者证书，这些都是验证组件的功劳)。</p>
<p>越狱的工作原理正是攻击这一信任链。所有的越狱工具的作者都需要找到这一信任链上的漏洞，从而禁止掉信任链中负责验证的组件。破解引导ROM通常是最可取的办法，因为该组件不会因为苹果今后的软件更新而改变。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于数据结构和内存中堆和栈，你可能还不知道的几个区别]]></title>
      <url>/2017/03/16/15/</url>
      <content type="html"><![CDATA[<p>堆和栈是数据结构中最常见的两种结构。<br><a id="more"></a></p>
<ol>
<li><p>数据结构中的堆和栈<br>堆和栈在数据结构中是两种不同的数据结构。 两者都是数据项按序排列的数据结构。<br>栈：像是装数据的桶或者箱子<br>栈是大家比较熟悉的一种数据结构，它是一种具有后进先出的数据结构，也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放入比较晚的物体）。<br>堆：像是一颗倒立的大树<br>堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
</li>
<li><p>内存分配中的堆和栈<br>我们现在经常用的并不是数据结构中的堆和栈，之所以说了数据结构中的堆和栈是为了和后面将要说的堆区和栈区区别开来，请大家一定要注意。<br>下面说一下C语言程序内存分配中的堆和栈，这里有必要把内存分配也提一下，大家不要嫌弃本姑娘萝莉啰嗦啦，一般情况下 程序存放在Rom或Flash中，运行事需要拷贝到内存中执行，内存会分别存储不同的信息。</p>
</li>
</ol>
<p>内存中的栈区处于相对较高的地址，以地址的增长方向为上的话，栈地址是向下增长的。<br>栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的。只读区是分配常量和程序代码空间的；以及其他一些分区。</p>
<p>来看一个很经典的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;  全局初始化区</span><br><span class="line">char *p1;  全局未初始化区</span><br><span class="line">void main ()&#123;</span><br><span class="line">    int b; 栈</span><br><span class="line">    char  s[] = &quot;abc&quot;;栈</span><br><span class="line">    char *p2; 栈</span><br><span class="line">    char *p3 = &quot;123456&quot;; 123456\0 在常量区，p3 在栈区</span><br><span class="line">    static  int c = 0； 全局（静态）初始化区</span><br><span class="line">    p1 = (char *)malloc(10);堆</span><br><span class="line">    p2 = (char *)malloc (20);堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>内存分配中栈区和堆区的区别<br>0、申请方式和回收方式不同<br>不知道你是否有点明白了，堆和栈的第一个区别就是申请方式的不同：栈（英文名字;stack）是系统自动分配空间的<br>，例如我们定义了一个 char a ；系统会自动的在栈上为其开辟空间。而堆（英文名字:heap）则是程序员根据需要自己申请的空间，例如malloc(10); 开辟是个字节的空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。</li>
</ol>
<p>1、 申请后系统的响应<br>栈 ： 只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统受到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆。<br>结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题</p>
<p>2、申请效率的比较<br>栈：  由系统自动分配，速度较快。但程序员是无法控制的。<br>堆：  是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<p>3、 申请大小的限制<br>栈： 在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>4、堆和栈中的内存内容<br>由于栈的大小限制，所以用子函数还是有物理意义的，而不仅仅是逻辑意义。<br>栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的吓一跳可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是有右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>5、 关于堆和栈一个比较形象的比喻<br>栈：使用栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、吃（使用），吃饱了就走，不必理会切菜，洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处就是快捷，但是自由度小。</p>
<p>堆：使用堆就像是自己动手做喜欢的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 一直弹出登录iCloud的解决方法]]></title>
      <url>/2017/01/05/11/</url>
      <content type="html"><![CDATA[<p>一直弹出的时候，你随便输入密码，输三次，它会出现让你重设密码，然后点击重设，会出现网页，然后直接按home键就可以 ，前提是必须要连上网。<br><a id="more"></a><br>一直弹出的时候，你随便输入密码，输三次，它会出现让你重设密码，然后点击重设，会出现网页，然后直接按home键就可以 ，前提是必须要连上网。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac下如何查看Git的全局忽略列表]]></title>
      <url>/2016/11/22/6/</url>
      <content type="html"><![CDATA[<p>有时在使用Git的时候会发现有些文件明明在目录里，但是Git却没有自动添加到版本跟踪里面，查看仓库的忽略列表也没有，那么有很大可能是在Git的全局忽略列表里。<br><a id="more"></a><br>有时在使用Git的时候会发现有些文件明明在目录里，但是Git却没有自动添加到版本跟踪里面，查看仓库的忽略列表也没有，那么有很大可能是在Git的全局忽略列表里。</p>
<p>打开Finder(如果连这个都不知道的话，还是用回Windows吧)<br>在显示器的顶部菜单选择前往-&gt;前往文件夹<br>输入~/.gitignore_global</p>
<p>右键用记事本打开即可</p>
<p>如果不显示，请允许Mac显示所有隐藏文件！！<br>打开终端，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true       此命令显示隐藏文件</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool false      此命令关闭显示隐藏文件</span><br></pre></td></tr></table></figure></p>
<p>命令运行之后需要重新加载Finder：快捷键option+command+esc，选中Finder，重新启动即可<br>重启电脑也可以。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3 单例模式]]></title>
      <url>/2016/11/16/8/</url>
      <content type="html"><![CDATA[<p>单例模式是开发中很常用的一种设计模式，一般几十行甚至十几行代码就可以搞定，Swift里面有这么几种单例的写法，供大家参考。<br><a id="more"></a><br>常见的有这么几种方法</p>
<ol>
<li>第一种<br>最简单也是最常用的，这里的所有单例init方法一定要定义成private的，不然外部依然可以使用init方法初始化变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final class Single: NSObject &#123;</span><br><span class="line">    static let shared = Single()</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final关键字的作用是这个类或方法不希望被继承和重写</p>
<ol>
<li>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public extension DispatchQueue &#123;</span><br><span class="line">    private static var onceToken = [String]()</span><br><span class="line">    public class func once(_ token: String, _ block:@escaping () -&gt; Void) &#123;</span><br><span class="line">        objc_sync_enter(self)</span><br><span class="line">        defer &#123;</span><br><span class="line">            objc_sync_exit(self)</span><br><span class="line">        &#125;</span><br><span class="line">        if onceToken.contains(token) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        onceToken.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Single2: NSObject &#123;</span><br><span class="line">    static func shared() -&gt; Single2 &#123;</span><br><span class="line">        struct Singleton &#123;</span><br><span class="line">            static var single = Single2()</span><br><span class="line">        &#125;</span><br><span class="line">        DispatchQueue.once(&quot;YouShaoduo&quot;) &#123;</span><br><span class="line">            Singleton.single = shared()</span><br><span class="line">        &#125;</span><br><span class="line">        return Singleton.single</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第二种完全是OC风格的单例，但是由于Swift3中废弃了原来的dispatch_once_t，所以需要先给DispatchQueue添加一个extension，实现原先的dispatch_once_t效果</p>
<ol>
<li><p>第三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private let single = Single3()</span><br><span class="line">final class Single3: NSObject &#123;</span><br><span class="line">    static var shared: Single3 &#123;</span><br><span class="line">        return single</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileprivate override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final class Single4: NSObject &#123;</span><br><span class="line">    static var shared: Single4 &#123;</span><br><span class="line">        struct Static &#123;</span><br><span class="line">            static let instance: Single4 = Single4()</span><br><span class="line">        &#125;</span><br><span class="line">        return Static.instance</span><br><span class="line">    &#125;</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方法的实现原理是在方法内定义静态变量</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设置Git区分文件名大小写]]></title>
      <url>/2016/11/16/5/</url>
      <content type="html"><![CDATA[<p>git 默认不区分文件名大小写。<br><a id="more"></a><br>git 默认不区分文件名大小写。</p>
<p>当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.</p>
<p>然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.</p>
<p>控制台输入git status 也不显示任何信息</p>
<p>那么就配置git 使其对文件名大小写敏感，直接在终端中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree(Git)不识别新添加的文件]]></title>
      <url>/2016/11/16/10/</url>
      <content type="html"><![CDATA[<p>今天在做项目的时候新建了一个viewController，但是sourceTree只显示新增了.h文件，在网上找了许多方法发现没有用，比如那个删掉.git隐藏文件的，删掉就SB了。<br><a id="more"></a><br>今天在做项目的时候新建了一个viewController，但是sourceTree只显示新增了.h文件，在网上找了许多方法发现没有用，比如那个删掉.git隐藏文件的，删掉就SB了。<br>找了好久没找到，无奈只能自己试验了。</p>
<p>工作目录中，新建一个文件，比如一个.h和.m文件。</p>
<p>但是，git无法识别这些文件。</p>
<p>用git status命令，返回目录是clean的。表明没有任何修改。说明git没有识别到这些新增加的文件。也说明这个问题是git内部的问题，跟用什么版本控制工具没关系（不是sourcetree的锅）</p>
<p>首先，找到了原因，那么强制给他加一下，用终端到文件目录下，然后输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add 1.m</span><br></pre></td></tr></table></figure></p>
<p>返回无法添加，说1.m已经处于.gitignore中。但是iganore中明明没有忽略这些m文件。</p>
<p>那就更狠一点，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f 1.m</span><br></pre></td></tr></table></figure></p>
<p>这样就可以将1.m添加到git的版本控制中。</p>
<p>如果直接git add -f 1.m</p>
<p>报错，无法找到文件1.m</p>
<p>那么就将1.m的完整路径输入即可。</p>
<p>建议先看一下全局忽略列表里有没有，查看Git全局忽略列表的方法在我的另一篇文章中有，请自行查阅。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 中的for循环，正序与逆序(倒序)]]></title>
      <url>/2016/11/02/9/</url>
      <content type="html"><![CDATA[<p>看了许多关于Swift  for循环的文章，发现基本上都是正序的for循环，对于逆序的我一直使用while循环，直到我发现了这个方法。。。<br><a id="more"></a><br>看了许多关于Swift  for循环的文章，发现基本上都是正序的for循环，对于逆序的我一直使用while循环，直到我发现了这个方法。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in (0...10).reversed() &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用这个就可以倒序for循环了</p>
<p>还有另一种比较优雅而且装X的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 3, through: 0, by: -1) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Swift 的 stride 函数返回一个任意可变步长 类型值的序列。可变步长类型是可以设置偏移量的一维标量。<br>他有两个变种，<br>from，to，最后一个值将会严格小(大)于to的值<br>stride(from:3, to:0, by:-1) 表示3，2，1</p>
<p>from，through，最后一个值将会小(大)于等于through的值<br>stride(from:3, through:0, by:-1) 表示3，2，1，0</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree超前一个版本，落后N个版本]]></title>
      <url>/2016/10/08/1/</url>
      <content type="html"><![CDATA[<p>在使用SourceTree的时候经常会遇见超前一个版本，落后N个版本的情况，遇见这种情况应该怎么办呢？</p>
<p>首先打开终端，最好是从SourceTree里面打开，菜单栏有个终端按钮。<br><a id="more"></a><br>在使用SourceTree的时候经常会遇见超前一个版本，落后N个版本的情况，遇见这种情况应该怎么办呢？</p>
<p>首先打开终端，最好是从SourceTree里面打开，菜单栏有个终端按钮。<br>然后输入(不要用这个，用下面的)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是将自己最近的一次提交撤销，回到push之前的状态。但是所有commit的内容就都消失了。非常不建议用这个参数，会牺牲太多的代码。。<br>如果不想让commit消失，可以改一下参数。用这个参数可以保证你提交的代码原封不动的保存下来。前提是你本地的工作台是干净的。如果不是请把所有代码都暂存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br></pre></td></tr></table></figure></p>
<p>执行这句话之后重新拉取一遍代码就可以了，push的都会撤销回来。</p>
<p>如果想一次回退多个push，可以这样：(例子是撤销最近三次的提交)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~3</span><br></pre></td></tr></table></figure></p>
<p>如果想回退到某个指定版本，在终端中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft 1234567</span><br></pre></td></tr></table></figure></p>
<p>1234567是要回退到的版本号，根据具体情况而定，这里只是举例子。<br>版本号可以不写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>版本号可以不写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>最后总结一下：</p>
<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSProcessInfo类方法]]></title>
      <url>/2016/08/26/13/</url>
      <content type="html"><![CDATA[<p>NSProcessInfo类中的方法很有用。<br><a id="more"></a><br>let i =NSProcessInfo.processInfo()<br>print(i.systemUptime)          //返回系统的运行时长<br>print(i.processName)           //返回当前正在执行的进程名称<br>print(i.arguments)             //以NSString对象数组的形式返回当前进程的参数<br>print(i.environment)           //返回变量/值对词典，以描述当前的环境变量（比如PATH和HOME）及其值<br>print(i.processIdentifier)     //返回进程标识符，它是操作系统赋予进程的唯一数字，用于识别每个正在运行的进程<br>print(i.processorCount)        //返回线程数量<br>print(i.globallyUniqueString)  //每次调用这个方法时，都返回不同的单值字符串，可以用这个字符串生成单值临时文件名<br>print(i.hostName)              //返回主机系统的名称（在笔者的iOS系统中，返回的是iPhone）<br>print(i.operatingSystemVersion)//返回操作系统的版本<br>print(i.operatingSystemVersionString)//返回操作系统的版本以及build号</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS获取当前版本号 Bundle ID等信息的方法]]></title>
      <url>/2016/08/23/7/</url>
      <content type="html"><![CDATA[<p>很多地方都会用到获取当前App的版本号。<br><a id="more"></a><br>1：获取bundle Id信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle mainBundle] bundleIdentifier];</span><br></pre></td></tr></table></figure></p>
<p>2：获取版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br></pre></td></tr></table></figure></p>
<p>3：获取build号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleVersion&quot;];</span><br></pre></td></tr></table></figure></p>
<p>4：获取App显示名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleDisplayName&quot;];</span><br></pre></td></tr></table></figure></p>
<p>其实 [[NSBundle mainBundle]infoDictionary] 获得的是一个字典，里边放着Info.plist文件中的各种信息，根据不同的键去即可，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CFBundleDevelopmentRegion</span><br><span class="line"></span><br><span class="line">CFBundleDisplayName</span><br><span class="line"></span><br><span class="line">CFBundleExecutable</span><br><span class="line"></span><br><span class="line">CFBundleExecutablePath</span><br><span class="line"></span><br><span class="line">CFBundleIdentifier</span><br><span class="line"></span><br><span class="line">CFBundleInfoDictionaryVersion = &quot;6.0&quot;;</span><br><span class="line"></span><br><span class="line">CFBundleInfoPlistURL</span><br><span class="line"></span><br><span class="line">CFBundleName</span><br><span class="line"></span><br><span class="line">CFBundlePackageType</span><br><span class="line"></span><br><span class="line">CFBundleShortVersionString</span><br><span class="line"></span><br><span class="line">CFBundleSignature</span><br><span class="line"></span><br><span class="line">CFBundleSupportedPlatforms</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
