<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[ShadowSocks启动报错undefined symbol EVP_CIPHER_CTX_cleanup]]></title>
      <url>/2018/10/12/51/</url>
      <content type="html"><![CDATA[<p>本文主要解决openssl升级到1.1.0以上版本，导致shadowsocks2.8.2启动报undefined symbol: EVP_CIPHER_CTX_cleanup错误。</p>
<a id="more"></a>
<p>如果在安装完ShadowSocks后，启动时报<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: /usr/local/ssl/lib/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</span><br><span class="line">shadowsocks start failed</span><br></pre></td></tr></table></figure></p>
<p>的错误。</p>
<p>在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nautilus /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</span><br></pre></td></tr></table></figure></p>
<h3 id="具体路径不同，请根据报错路径而定，但目的只有一个，就是找到openssl-py文件。"><a href="#具体路径不同，请根据报错路径而定，但目的只有一个，就是找到openssl-py文件。" class="headerlink" title="具体路径不同，请根据报错路径而定，但目的只有一个，就是找到openssl.py文件。"></a>具体路径不同，请根据报错路径而定，但目的只有一个，就是找到openssl.py文件。</h3><p>如果nautilus指令报错，那就用cd命令到这个目录下，使用vim编辑修改openssl.py文件。</p>
<p>如果是用文本文档打开，那搜索CIPHER_CTX_cleanup，应该有两处，替换为CIPHER_CTX_reset，然后保存文件。</p>
<p>如果是用vim编辑，那么输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:%s/cleanup/reset/</span><br><span class="line">:x</span><br></pre></td></tr></table></figure></p>
<p>然后重新运行Shadowsocks即可。</p>
<p><a href="https://kionf.com/2016/12/15/errornote-ss/" target="_blank" rel="noopener">具体原因可以参考这篇文章</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kali Linux ShadowSocks]]></title>
      <url>/2018/10/12/50/</url>
      <content type="html"><![CDATA[<p>kali里很多工具使用需要科学上网，谷歌搜索也一样，下面介绍一种最简单的方法</p>
<a id="more"></a>
<p>1.首先你要有一个能翻墙的梯子。。。</p>
<p>2.安装shadowsocks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>如果系统中没有pip命令，请执行以下命令安装pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get install python-pip</span><br><span class="line"></span><br><span class="line">python-setuptools m2crypto</span><br></pre></td></tr></table></figure></p>
<p>3.启动shadowsocks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# sslocal -s 你的服务器ip -p 服务器端口号 -k &quot;登录密码&quot; -b 127.0.0.1 -l 1080 -m aes-256-cfb -d start -vv</span><br></pre></td></tr></table></figure>
<p>按回车之后出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-06-20 13:53:42 INFO     loading libcrypto from libcrypto.so.1.1</span><br><span class="line">started</span><br></pre></td></tr></table></figure>
<p>说明开启成功。</p>
<p>sslocal命令行里，-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认aes-256-cfb</p>
<p>然后直接输入proxychains firefox</p>
<p>浏览器无需配置任何代理，即可打开火狐浏览器科学上网啦。</p>
<p>如果启动报错，请参考这篇文章：<br><a href="https://blog.csdn.net/paradiseduo/article/details/80745022" target="_blank" rel="noopener">ShadowSocks启动报错undefined symbol EVP_CIPHER_CTX_cleanup</a> </p>
]]></content>
      
        
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 使用SSH连接VPS(搬瓦工)]]></title>
      <url>/2018/10/12/49/</url>
      <content type="html"><![CDATA[<p>其实搬瓦工自带SSH服务端，因此这里只需要配置客户端就可以了。</p>
<p>SSH的地址和端口可以直接在控制台看到。</p>
<a id="more"></a>
<img src="/2018/10/12/49/20180626151142475.png">
<p>这里的SSH Port是端口号，用户名是root@IP address</p>
<p>1 在Mac OS上打开终端Terminal<br>2 输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@搬瓦工VPS的IP地址 -p 端口号</span><br></pre></td></tr></table></figure></p>
<p>具体例子如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@12.34.56.78 -p 12345</span><br></pre></td></tr></table></figure></p>
<p>回车之后会让你输入root的密码，这里可以选择重置root密码。</p>
<p>步骤如下：<br><img src="/2018/10/12/49/20180626151226641.png"></p>
<img src="/2018/10/12/49/20180626151237918.png">
<img src="/2018/10/12/49/20180626151251470.png">
<p>重置密码成功后，要记得重新启动 VPS 。</p>
<p>如果重置密码时一直报VPS未关闭的错误，但是你已经关闭了VPS，那么可以看这篇文章</p>
<p><a href="https://blog.csdn.net/paradiseduo/article/details/80815688" target="_blank" rel="noopener">搬瓦工 VPS 已关机但是无法修改root密码</a> </p>
]]></content>
      
        
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搬瓦工 VPS 已关机但是无法修改root密码]]></title>
      <url>/2018/10/12/48/</url>
      <content type="html"><![CDATA[<p>按照正常的流程，在KVM控制台点击stop按钮之后，再选择Root password modification重置密码，发现依然报错</p>
<a id="more"></a>
<p>Failed to reset root password (739102)<br>Additional information: 992800002 VPS is currently running.<br>Please stop the VPS before attempting to modify root password.</p>
<p>解决方法很简单。<br>我们进入 KiwiVM 后台之后，让 VPS 处于开机状态（running），然后点击左侧菜单的 Root shell – basic，然后输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;root:mypassword&quot; | chpasswd</span><br></pre></td></tr></table></figure></p>
<p>最好是自己打一下。 </p>
<p>注意空格，其中“root:mypassword”之间的冒号是英文冒号，且中间没有空格。“root”就是用户名，不需要改动，“mypassword”就是你要设置的密码，根据自己情况进行填写。</p>
<p>输入之后回车，即可完成密码的修改。之后我们就可以通过 SSH 客户端登陆我们的 VPS 了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 梯子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用UIDocumentPickerViewController从手机上选文件]]></title>
      <url>/2018/03/01/47/</url>
      <content type="html"><![CDATA[<p>有时候会有这么一些需求,需要用户上传自己的一些xml,doc,pdf文档.可是iOS上并没有直观的文件管理系统.这时候Document Picker就可以帮助我们访问iCould,dropBox等应用中的文件.然后进行相关操作.</p>
<a id="more"></a>
<p>首先应该在项目中添加对iCould的支持, 在TARGETS-Capabilities中把iCloud的按钮打开,勾选iCloud Documents.</p>
<p>然后开始初始化一个Document Picker,并且声明所支持文件的类型.然后就会弹出一个iCloud Drive的文档选择器.这个选择器需要我们在手机上登录自己的iCloud的账号,然后我们就可以选择在iCloud中存放的文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *documentTypes = @[@&quot;public.content&quot;, @&quot;public.text&quot;, @&quot;public.source-code &quot;, @&quot;public.image&quot;, @&quot;public.audiovisual-content&quot;, @&quot;com.adobe.pdf&quot;, @&quot;com.apple.keynote.key&quot;, @&quot;com.microsoft.word.doc&quot;, @&quot;com.microsoft.excel.xls&quot;, @&quot;com.microsoft.powerpoint.ppt&quot;];</span><br><span class="line"></span><br><span class="line">UIDocumentPickerViewController *documentPicker = [[UIDocumentPickerViewController alloc] initWithDocumentTypes:documentTypes inMode:UIDocumentPickerModeOpen];</span><br><span class="line">documentPicker.delegate = self;</span><br><span class="line">documentPicker.modalPresentationStyle = UIModalPresentationFullScreen;</span><br><span class="line">[self presentViewController:documentPicker animated:YES completion:nil];</span><br></pre></td></tr></table></figure>
<p>选择之后根据documentPicker的代理方法- (void)documentPicker:(UIDocumentPickerViewController <em>)controller didPickDocumentAtURL:(NSURL </em>)url; 获取到文档的地址.然后NSFileCoordinator读取文件地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)documentPicker:(UIDocumentPickerViewController *)controller didPickDocumentAtURL:(NSURL *)url &#123;</span><br><span class="line"></span><br><span class="line">    BOOL fileUrlAuthozied = [url startAccessingSecurityScopedResource];</span><br><span class="line">    if(fileUrlAuthozied)&#123;</span><br><span class="line">        NSFileCoordinator * fileCoordinator = [[NSFileCoordinator alloc] init];</span><br><span class="line">        NSError * error;</span><br><span class="line">        [fileCoordinator coordinateReadingItemAtURL:url options:0 error:&amp;error byAccessor:^(NSURL *newURL) &#123;</span><br><span class="line">            NSString * fileName = [newURL lastPathComponent];</span><br><span class="line">            NSData * data = [NSData dataWithContentsOfURL:newURL];</span><br><span class="line">        &#125;];</span><br><span class="line">        [url stopAccessingSecurityScopedResource];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //Error handling</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocoa Touch 中的新特性]]></title>
      <url>/2018/03/01/46/</url>
      <content type="html"><![CDATA[<p>这些特性都是iOS11以后的一些特性，现在整理了一下，以备以后用到。</p>
<a id="more"></a>
<h2 id="Drag-Drop-新的交互方式-拖拽"><a href="#Drag-Drop-新的交互方式-拖拽" class="headerlink" title="Drag Drop 新的交互方式 拖拽"></a>Drag Drop 新的交互方式 拖拽</h2><h3 id="Drag"><a href="#Drag" class="headerlink" title="Drag"></a>Drag</h3><p>需要 Drag 的对象要 add 一个 UIDragInteraction ，用法类似于 UIGestureRecognizer 。<br>UIDragInteraction 有一个 UIDragInteractionDelegate 的代理，可以提供数据，浮起的动画，和自定义的拖动时的动画。</p>
<h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p>接收 Drag 的对象的容器，容器要实现一个 UIDropInteractionDelegate 的代理，可以来根据拖入的对象调整当前的界面。</p>
<h3 id="TableView-CollectionView-TextView-TextField-WebView-原生控件都支持"><a href="#TableView-CollectionView-TextView-TextField-WebView-原生控件都支持" class="headerlink" title="TableView, CollectionView, TextView, TextField, WebView 原生控件都支持"></a>TableView, CollectionView, TextView, TextField, WebView 原生控件都支持</h3><p>配合剪切板 UIPasteConfiguration 使用会更加方便。</p>
<p>这个功能手机上可以在 文件 这个系统 app 中体验，里面的 tableview 和 collectionview 的 item 都是支持拖拽的。</p>
<h2 id="File-Manager"><a href="#File-Manager" class="headerlink" title="File Manager"></a>File Manager</h2><h3 id="UIDocumentBrowserViewController"><a href="#UIDocumentBrowserViewController" class="headerlink" title="UIDocumentBrowserViewController"></a>UIDocumentBrowserViewController</h3><p>多了一个文件管理的 VC，默认里面会显示当前 app 权限以内的文件，包括本地的和存在 iCloud 的【如果三方 app 在 info.plist 中声明了 UISupportsDocumentBrowser 或者 UIFileSharingEnabled 和 LSSupportsOpeningDocumentsInPlace 的话，可以获得第三方 app 的文件】。</p>
<p>构造方法如下【该构造还提供了文件筛选的能力】：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIDocumentBrowserViewController* view  = [[UIDocumentBrowserViewController alloc]</span><br><span class="line">initForOpeningFilesWithContentTypes:@[@&quot;.txt&quot;,@&quot;.pages&quot;,@&quot;.pdf&quot;]];</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是官方文档中提到，在使用该 VC 时。</p>
<ol>
<li>务必把文件管理里的 VC 作为应用的 根 VC，不要把它放在 navigation，tab 或者 split 视图中，也不要通过模态的样式展现出来。有需求的话用 UIDocumentPickerViewController 来替代。<ol>
<li>由于文件可能被任何 app 中的 UIDocumentBrowserViewController 修改，所以对文件的操作尽量通过 UIDocument 子类 或者 NSFilePresenter 和 NSFileCoordinator 对象来操作。</li>
</ol>
</li>
</ol>
<h2 id="新的-UINavigationBar"><a href="#新的-UINavigationBar" class="headerlink" title="新的 UINavigationBar"></a>新的 UINavigationBar</h2><p>增加了大的标题栏【感觉不好看，而且会变卡，具体的去体验一下App Store里更新那个页面】，新增的 api，控制后面的 vc 层级是否需要继续展示大的 title，或者全部使用大的 title。可以在系统的 app 中体验这个特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//声明大标题</span><br><span class="line">self.navigationController.navigationBar.prefersLargeTitles = YES;</span><br><span class="line">//包含三种模式 aoto / always / never （后续 present 的view 是否需要大标题）</span><br><span class="line">self.navigationController.navigationItem.largeTitleDisplayMode = UINavigationItemLargeTitleDisplayModeAutomatic;</span><br></pre></td></tr></table></figure></p>
<p>增加了统一的 navigation 搜索栏，不用再加在 tableview 的 header 中了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController.navigationItem.searchController</span><br></pre></td></tr></table></figure></p>
<p>现在 navigation bar 是独立的，和你的 content vie 无关，为了更好的处理这些系统 view 的布局的变化，提供了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.view.safeAreaLayoutGuide // auto layout @available(iOS 11.0, *)</span><br><span class="line">self.view.safeAreaInsets // 代码布局 @available(iOS 11.0, *)</span><br><span class="line"></span><br><span class="line">- (void)viewSafeAreaInsetsDidChange&#123;</span><br><span class="line">//当布局变化的时候的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h2><p>解决了 navigation vc 和 scrollview 的 contentInset 的冲突的问题，现在 navigation vc 不在修改 contentInset 了。<br>增加了 contentInsetAdjustmentBehavior 这个属性，默认为 UIScrollViewContentInsetAdjustmentAutomatic ,可以用来自定义滑动时候的便宜效果。<br>通过 adjustedContentInset 可以获取当前的偏移量。</p>
<h2 id="TableView-的修改"><a href="#TableView-的修改" class="headerlink" title="TableView 的修改"></a>TableView 的修改</h2><h3 id="滑动操作"><a href="#滑动操作" class="headerlink" title="滑动操作"></a>滑动操作</h3><p>Row 增加了 UISwipeActionsConfiguration ，用来处理滑动操作。<br>UISwipeActionsConfiguration 通过 UIContextualAction 数组来初始化，可以配置不同的动作，左滑右滑等，还能配置 UISwipeActionsConfiguration 的 performsFirstActionWithFullSwipe 【Bool】属性 来决定第一个事件是否响应完整的滑动。</p>
<h3 id="新的分界线"><a href="#新的分界线" class="headerlink" title="新的分界线"></a>新的分界线</h3><p>可以配置相对值和绝对值的 Inset<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.separatorInsetReference = UITableViewSeparatorInsetFromAutomaticInsets;</span><br></pre></td></tr></table></figure></p>
<h2 id="密码自动填写功能"><a href="#密码自动填写功能" class="headerlink" title="密码自动填写功能"></a>密码自动填写功能</h2><p>场景是在 web 上登录账户之后，点击下线 app ，然后调到 appstore，打开 app ，输入密码，这时候可以自动填写。【应该需要网页 / app 端的支持】<br>这里没有具体展开，有个专门介绍这个 session 【Introducing Password AutoFil】</p>
<h2 id="Asset-Catalogs-的调整"><a href="#Asset-Catalogs-的调整" class="headerlink" title="Asset Catalogs 的调整"></a>Asset Catalogs 的调整</h2><p>现在颜色也能放在 Asset Catalogs 中了，更方便的使用广色域的颜色。代码里可以通过下面的方法获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color = [UIColor colorNamed:@&quot;purple&quot;];</span><br></pre></td></tr></table></figure></p>
<h2 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h2><p>通过 UIScreen 的 maximumFramesPerSecond 可以获取当前屏幕的刷新率<br>获取屏幕的刷新率，增强滑动和动画效果。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIDocumentPickerViewController的documentTypes]]></title>
      <url>/2018/03/01/45/</url>
      <content type="html"><![CDATA[<p>最近在研究UIDocumentPickerViewController的使用，在他的初始化方法里就被卡住了，对其中documentTypes这个参数，系统注释里写的很少，网上找也废了很大的力气，这里总结一下。</p>
<a id="more"></a>
<p>先来看一下这个初始化方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Initializes the picker instance for selecting a document in a remote location. The valid modes are Import and Open.</span><br><span class="line">public init(documentTypes allowedUTIs: [String], in mode: UIDocumentPickerMode)</span><br></pre></td></tr></table></figure></p>
<p>这个参数是要传入一个字符串数组，数组的内容是需要支持的文件类型。如果想深究这些字符串是如何定义，为什么这么定义，请移步<a href="https://www.jianshu.com/p/d6fe1e7af9b6" target="_blank" rel="noopener">这里</a>，本篇文章只讲用什么。</p>
<p>先列几个常用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;com.microsoft.powerpoint.​ppt&quot;,</span><br><span class="line">&quot;com.microsoft.word.doc&quot;,</span><br><span class="line">&quot;com.microsoft.excel.xls&quot;,</span><br><span class="line">&quot;com.microsoft.powerpoint.​pptx&quot;,</span><br><span class="line">&quot;com.microsoft.word.docx&quot;,</span><br><span class="line">&quot;com.microsoft.excel.xlsx&quot;,</span><br><span class="line">&quot;public.avi&quot;,</span><br><span class="line">&quot;public.3gpp&quot;,</span><br><span class="line">&quot;public.mpeg-4&quot;,</span><br><span class="line">&quot;com.compuserve.gif&quot;,</span><br><span class="line">&quot;public.jpeg&quot;,</span><br><span class="line">&quot;public.png&quot;,</span><br><span class="line">&quot;public.plain-text&quot;,</span><br><span class="line">&quot;com.adobe.pdf&quot;</span><br></pre></td></tr></table></figure></p>
<p>大家看后缀名应该就能看懂。</p>
<p>至于完整版，大家可以看这里：<br><a href="https://developer.apple.com/library/content/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259" target="_blank" rel="noopener">苹果官方文档</a></p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修改UIDocumentPickerViewController navigation bar buttons color]]></title>
      <url>/2018/03/01/44/</url>
      <content type="html"><![CDATA[<p>最近在研究UIDocumentPickerViewController的使用，发现微信的UIDocumentPickerViewController上面Button的颜色都是微信绿，所以自己研究了一下，看看如何自定义这些Button的颜色。</p>
<a id="more"></a>
<p>新建一个ViewContorller继承于UIDocumentPickerViewController，然后再viewWillAppear的时候通过这几句代码设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIBarButtonItem.appearance().setTitleTextAttributes([NSAttributedStringKey.foregroundColor:self.view.tintColor], for: .normal)</span><br><span class="line">UIButton.appearance().tintColor = self.view.tintColor</span><br></pre></td></tr></table></figure></p>
<p>这里的tintColor可以设置成任意的颜色，这里是设置成系统自己的颜色。</p>
<p>当然要做到像微信那样全是绿色，可以把下面这几个也设置上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImageView.appearance().tintColor = self.view.tintColor</span><br><span class="line">UITabBar.appearance().tintColor = self.view.tintColor</span><br><span class="line">UIView.appearance(whenContainedInInstancesOf: [UIAlertController.self]).tintColor = self.view.tintColor</span><br></pre></td></tr></table></figure></p>
<p>千万要记住在页面dismiss之后，将这些tintColor设置成原来的值(如果原来没设置，就设置为self.view.tintColor，系统的默认值)</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS CallKit与PushKit的集成]]></title>
      <url>/2018/01/26/43/</url>
      <content type="html"><![CDATA[<p>很多VoIP的开发者发现，升级到Xcode9以后，原来的Voice over IP的选项消失了，需要自行去info.plist中添加App provides Voice over IP services。在某些时候，对传统VoIP架构的支持将被删除，于是所有的VoIP应用将不得不转移到新的基于PushKit的VoIP架构</p>
<a id="more"></a>
<p>这里我就来简单介绍一下如何集成CallKit与PushKit。</p>
<p>要集成，首先就要导入framework，图中的三个framework都要导入，第一个framework是从通讯录中直接拨打App电话所需要的。<br><img src="/2018/01/26/43/A8E35734-9BDD-4921-A7E8-64E37AD3C407.png"></p>
<h2 id="PushKit"><a href="#PushKit" class="headerlink" title="PushKit"></a>PushKit</h2><p>这个是iOS8后才支持的框架，如果你的项目现在还在支持iOS7，那么你可以以辞职为筹码去跟产品经理斗智斗勇了。</p>
<p>集成PushKit很简单，跟注册普通的APNS推送一个样，先去注册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//import PushKit  这个加在文件头部。大家都是老司机了，缺头文件自己加。</span><br><span class="line">let voipRegistry = PKPushRegistry(queue: DispatchQueue.main)</span><br><span class="line">voipRegistry.delegate = self</span><br><span class="line">voipRegistry.desiredPushTypes = [PKPushType.voIP]</span><br></pre></td></tr></table></figure></p>
<p>然后注册成功没呢？看这个代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) &#123;</span><br><span class="line">    if pushCredentials.token.count &gt; 0 &#123;</span><br><span class="line">        var token = NSString(format: &quot;%@&quot;, pushCredentials.token as CVarArg) as String</span><br><span class="line">        print(&quot;pushRegistry credentialsToken \(token)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家注意了，这里的token跟APNS的deviceToken虽然长度和格式一样，但是内容是不同的。这是因为苹果需要区分这是PushKit的推送还是APNS的推送。</p>
<p>注册好token后，就可以上传给自己的服务器了。然后需要自己的服务器发推送。<br>这里就牵扯到证书的问题了，首先要知道的是，VoIP的PushKit推送证书跟APNS的是两个不同的证书，需要自己去生成，然后导出p12文件给服务器。<br><img src="/2018/01/26/43/1870246-f767b26f3aceb124.png"></p>
<p>导出证书这里就不做过多赘述，只要知道一点，VoIP的PushKit证书只有Product环境的，但是测试环境也能使。<br><img src="/2018/01/26/43/1870246-5d199f5d045e84c1.png"></p>
<p>导出p12文件，注意导出的文件大小应该有6kb，如果只有一半说明你没把公钥导进去。<br><img src="/2018/01/26/43/1870246-e5d4fe2e73dfc69e.png"></p>
<p>下面就可以测试推送啦。。。<br>我们先来看看在哪里接推送，Appdelegate里面有这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType) &#123;</span><br><span class="line">    guard type == .voIP else &#123;</span><br><span class="line">        log.info(&quot;Callkit&amp; pushRegistry didReceiveIncomingPush But Not VoIP&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(&quot;pushRegistry didReceiveIncomingPush&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法里的PKPushPayload里有个dictionaryPayload，是个字典，作用跟APNS里的info一个样。。。要学会举一反三呐。。</p>
<p>至此，一套PushKit的推送流程就搭建好了。。如果服务器没搞好，但是想测试的话，可以用这个：<br><a href="https://github.com/noodlewerk/NWPusher" target="_blank" rel="noopener">https://github.com/noodlewerk/NWPusher</a><br>一个很牛逼的Push测试软件。用的HTTP2，只要证书选对，token填对，就能发啦。。</p>
<h2 id="CallKit"><a href="#CallKit" class="headerlink" title="CallKit"></a>CallKit</h2><p>重点来了。。<br>对于CallKit首先要明确一点。在你使用的时候，不要把他看成一个很复杂的框架，他就是系统的打电话页面，跟你自己写的打电话页面一样一样的；只要是页面，就可以调用显示和消失，可以对上面的按钮进行操作。</p>
<p>工欲善其事必先利其器，我们首先来创建几个工具类：<br>第一个，Call类，用来管理CallKit的电话，注意是管理CallKit的电话，跟你自己的电话逻辑不冲突！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">enum CallState &#123; //状态都能看得懂吧。。看不懂的自己打个电话想想流程。</span><br><span class="line">    case connecting</span><br><span class="line">    case active</span><br><span class="line">    case held</span><br><span class="line">    case ended</span><br><span class="line">    case muted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ConnectedState &#123;</span><br><span class="line">    case pending</span><br><span class="line">    case complete</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Call &#123;</span><br><span class="line"></span><br><span class="line">    let uuid: UUID //来电的唯一标识符</span><br><span class="line">    let outgoing: Bool //是拨打的还是接听的</span><br><span class="line">    let handle: String //后面很多地方用得到，名字都是handle哈，可以理解为电话号码，其实就是自己App里被呼叫方的账号(至少我们是这样的)。。</span><br><span class="line"></span><br><span class="line">    var state: CallState = .ended &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            stateChanged?()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var connectedState: ConnectedState = .pending &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            connectedStateChanged?()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var stateChanged: (() -&gt; Void)?</span><br><span class="line">    var connectedStateChanged: (() -&gt; Void)?</span><br><span class="line"></span><br><span class="line">    init(uuid: UUID, outgoing: Bool = false, handle: String) &#123;</span><br><span class="line">        self.uuid = uuid</span><br><span class="line">        self.outgoing = outgoing</span><br><span class="line">        self.handle = handle</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func start(completion: ((_ success: Bool) -&gt; Void)?) &#123;</span><br><span class="line">        completion?(true)</span><br><span class="line"></span><br><span class="line">        DispatchQueue.main.asyncAfter(wallDeadline: DispatchWallTime.now() + 3) &#123;</span><br><span class="line">            self.state = .connecting</span><br><span class="line">            self.connectedState = .pending</span><br><span class="line"></span><br><span class="line">            DispatchQueue.main.asyncAfter(wallDeadline: DispatchWallTime.now() + 1.5) &#123;</span><br><span class="line">                self.state = .active</span><br><span class="line">                self.connectedState = .complete</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func answer() &#123;</span><br><span class="line">        state = .active</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func end() &#123;</span><br><span class="line">        state = .ended</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后建立一个Audio类，用来管理音频，铃声的播放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func configureAudioSession() &#123; //这里必须这么做。。不然会出现没铃声的情况。原因嘛。。我也不知道。。</span><br><span class="line">    log.info(&quot;Callkit&amp; Configuring audio session&quot;)</span><br><span class="line">    let session = AVAudioSession.sharedInstance()</span><br><span class="line">    do &#123;</span><br><span class="line">        try session.setCategory(AVAudioSessionCategoryPlayAndRecord)</span><br><span class="line">        try session.setMode(AVAudioSessionModeVoiceChat)</span><br><span class="line">    &#125; catch (let error) &#123;</span><br><span class="line">        log.info(&quot;Callkit&amp; Error while configuring audio session: \(error)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startAudio() &#123;</span><br><span class="line">    log.info(&quot;Callkit&amp; Starting audio&quot;)</span><br><span class="line">    //开始播放铃声</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func stopAudio() &#123;</span><br><span class="line">    log.info(&quot;Callkit&amp; Stopping audio&quot;)</span><br><span class="line">    //停止播放铃声</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工具类都做好了，下面开始集成CallKit<del>~</del><del>~</del>~<br>首先，建立一个CallKitManager的类，只要是用户发起的动作，都跟这个类有关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS 10.0, *)</span><br><span class="line">class CallKitManager &#123;</span><br><span class="line"></span><br><span class="line">    static let shared = CallKitManager()</span><br><span class="line"></span><br><span class="line">    var callsChangedHandler: (() -&gt; Void)?</span><br><span class="line"></span><br><span class="line">    private let callController = CXCallController()</span><br><span class="line">    private(set) var calls = [Call]()</span><br><span class="line"></span><br><span class="line">    private init()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    func callWithUUID(uuid: UUID) -&gt; Call? &#123;</span><br><span class="line">        guard let index = calls.index(where: &#123; $0.uuid == uuid &#125;) else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return calls[index]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func add(call: Call) &#123;</span><br><span class="line">        calls.append(call)</span><br><span class="line">        call.stateChanged = &#123; [weak self] in</span><br><span class="line">        guard let strongSelf = self else &#123; return &#125;</span><br><span class="line">            strongSelf.callsChangedHandler?()</span><br><span class="line">        &#125;</span><br><span class="line">        callsChangedHandler?()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func remove(call: Call) &#123;</span><br><span class="line">        guard let index = calls.index(where: &#123; $0 === call &#125;) else &#123; return &#125;</span><br><span class="line">        calls.remove(at: index)</span><br><span class="line">        callsChangedHandler?()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func removeAllCalls() &#123;</span><br><span class="line">        calls.removeAll()</span><br><span class="line">        callsChangedHandler?()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想必大家都发现了，现在CallKitManager里面只有callController跟CallKit有关系，不急，我们一点一点的把这个类丰富起来。这么做是为了加深理解，并不是简单的复制代码，到时候出了问题知道在哪进行改动。</p>
<p>现在CallKitManager里面的函数，其实是用了我们自己写的Call类，对CallKit做一个逻辑的管理，大家发现了，这里就跟队列一个样，add、remove、removeAll、callWithUUID(根据uuid去找到这个call对象)。</p>
<p>然后我们来看一下callController这个CXCallController对象，CallKitManager里面目前唯一与CallKit有关系就是他。CXCallController可以让系统收到App的一些Request，用户的action，App内部的事件。</p>
<p>我们现在来丰富CallKitManager，先从打电话开始：<br>添加下列代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func startCall(handle: String, videoEnabled: Bool) &#123;</span><br><span class="line">    //一个 CXHandle 对象表示了一次操作，同时指定了操作的类型和值。App支持对电话号码进行操作，因此我们在操作中指定了电话号码。</span><br><span class="line">    let handle = CXHandle(type: .phoneNumber, value: handle)</span><br><span class="line">    //一个 CXStartCallAction 用一个 UUID 和一个操作作为输入。</span><br><span class="line">    let startCallAction = CXStartCallAction(call: UUID(), handle: handle)</span><br><span class="line">    //你可以通过 action 的 isVideo 属性指定通话是音频还是视频。</span><br><span class="line">    startCallAction.isVideo = videoEnabled</span><br><span class="line">    let transaction = CXTransaction(action: startCallAction)</span><br><span class="line">    requestTransaction(transaction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用 callController 的 request(_:completion:) 。系统会请求 CXProvider 执行这个 CXTransaction，这会导致你实现的委托方法被调用。</span><br><span class="line">private func requestTransaction(_ transaction: CXTransaction) &#123;</span><br><span class="line">    callController.request(transaction) &#123; error in</span><br><span class="line">        if let error = error &#123;</span><br><span class="line">            log.info(&quot;Callkit&amp; Error requesting transaction: \(error)&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Callkit&amp; Requested transaction successfully&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是迫不及待的想调用一下这个函数了？但是调用后发现，并没有什么事情发生。。<br>其实就是这样。。因为你只向系统发送了要打电话的请求，但是系统也要告诉你你现在可不可以打，这样才叫与系统通讯嘛。。不能只是单方面的要求，还需要对方的应答。这里其实就跟服务器请求一个样，发要求，等回应，收到回应后进行下一步操作。</p>
<p>那么这里，我们就需要来接收系统的回应了。。怎么接收到呢？<br>我们新建一个类，名字叫ProviderDelegate，继承自谁不重要，重要的是需要遵循CXProviderDelegate这个代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS 10.0, *)</span><br><span class="line">class ProviderDelegate: NSObject, CXProviderDelegate &#123;</span><br><span class="line">    static let shared = ProviderDelegate()</span><br><span class="line">    //ProviderDelegate 需要和 CXProvider 和 CXCallController 打交道，因此保持两个对二者的引用。</span><br><span class="line">    private let callManager: CallKitManager //还记得他里面有个callController嘛。。</span><br><span class="line">    private let provider: CXProvider</span><br><span class="line"></span><br><span class="line">    override init() &#123;</span><br><span class="line">        self.callManager = CallKitManager.shared</span><br><span class="line">        //用一个 CXProviderConfiguration 初始化 CXProvider，前者在后面会定义成一个静态属性。CXProviderConfiguration 用于定义通话的行为和能力。</span><br><span class="line">        provider = CXProvider(configuration: type(of: self).providerConfiguration)</span><br><span class="line">        super.init()</span><br><span class="line">        //为了能够响应来自于 CXProvider 的事件，你需要设置它的委托。</span><br><span class="line">        provider.setDelegate(self, queue: nil)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过设置CXProviderConfiguration来支持视频通话、电话号码处理，并将通话群组的数字限制为 1 个，其实光看属性名大家也能看得懂吧。</span><br><span class="line">    static var providerConfiguration: CXProviderConfiguration &#123;</span><br><span class="line">        let providerConfiguration = CXProviderConfiguration(localizedName: &quot;Mata Chat&quot;)//这里填你App的名字哦。。</span><br><span class="line">        providerConfiguration.supportsVideo = false</span><br><span class="line">        providerConfiguration.maximumCallsPerCallGroup = 1</span><br><span class="line">        providerConfiguration.maximumCallGroups = 1</span><br><span class="line">        providerConfiguration.supportedHandleTypes = [.phoneNumber]</span><br><span class="line">        return providerConfiguration</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这个方法牛逼了，它是用来更新系统电话属性的。。</span><br><span class="line">    func callUpdate(handle: String, hasVideo: Bool) -&gt; CXCallUpdate &#123;</span><br><span class="line">        let update = CXCallUpdate()</span><br><span class="line">        update.localizedCallerName = &quot;ParadiseDuo&quot;//这里是系统通话记录里显示的联系人名称哦。需要显示什么按照你们的业务逻辑来。</span><br><span class="line">        update.supportsGrouping = false</span><br><span class="line">        update.supportsHolding = false</span><br><span class="line">        update.remoteHandle = CXHandle(type: .phoneNumber, value: handle) //填了联系人的名字，怎么能不填他的handle(&apos;电话号码&apos;)呢，具体填什么，根据你们的业务逻辑来</span><br><span class="line">        update.hasVideo = hasVideo</span><br><span class="line">        return update</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //CXProviderDelegate 唯一一个必须实现的代理方法！！当 CXProvider 被 reset 时，这个方法被调用，这样你的 App 就可以清空所有去电，会到干净的状态。在这个方法中，你会停止所有的呼出音频会话，然后抛弃所有激活的通话。</span><br><span class="line">    func providerDidReset(_ provider: CXProvider) &#123;</span><br><span class="line">        stopAudio()</span><br><span class="line">        for call in callManager.calls &#123;</span><br><span class="line">            call.end()</span><br><span class="line">        &#125;</span><br><span class="line">        callManager.removeAllCalls()</span><br><span class="line">        //这里添加你们挂断电话或抛弃所有激活的通话的代码。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的ProviderDelegate准备工作做好后，继续我们打电话的逻辑，在ProviderDelegate添加代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func provider(_ provider: CXProvider, perform action: CXStartCallAction) &#123;</span><br><span class="line">    //向系统通讯录更新通话记录</span><br><span class="line">    let update = self.callUpdate(handle: action.handle.value, hasVideo: action.isVideo)</span><br><span class="line">    provider.reportCall(with: action.callUUID, updated: update)</span><br><span class="line"></span><br><span class="line">    let call = Call(uuid: action.callUUID, outgoing: true, handle: action.handle.value)</span><br><span class="line">    //当我们用 UUID 创建出 Call 对象之后，我们就应该去配置 App 的音频会话。和呼入通话一样，你的唯一任务就是配置。真正的处理在后面进行，也就是在 provider(_:didActivate) 委托方法被调用时</span><br><span class="line">    configureAudioSession()</span><br><span class="line">    //delegate 会监听通话的生命周期。它首先会会报告的就是呼出通话开始连接。当通话最终连上时，delegate 也会被通知。</span><br><span class="line">    call.connectedStateChanged = &#123; [weak self] in</span><br><span class="line">        guard let w = self else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if call.connectedState == .pending &#123;</span><br><span class="line">            w.provider.reportOutgoingCall(with: call.uuid, startedConnectingAt: nil)</span><br><span class="line">        &#125; else if call.connectedState == .complete &#123;</span><br><span class="line">            w.provider.reportOutgoingCall(with: call.uuid, connectedAt: nil)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用 call.start() 方法会导致 call 的生命周期变化。如果连接成功，则标记 action 为 fullfill。</span><br><span class="line">    call.start &#123; [weak self] (success) in</span><br><span class="line">        guard let w = self else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if success &#123;</span><br><span class="line">            //这里填写你们App内打电话的逻辑。。</span><br><span class="line"></span><br><span class="line">            w.callManager.add(call: call)</span><br><span class="line">            //所有的Action只有调用了fulfill()之后才算执行完毕。</span><br><span class="line">            action.fulfill()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            action.fail()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当系统激活 CXProvider 的 audio session时，委托会被调用。这给你一个机会开始处理通话的音频。</span><br><span class="line">func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) &#123;</span><br><span class="line">    startAudio() //一定要记得播放铃声呐。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，通过CallKit拨打电话的逻辑就完成了。你只要在自己App需要打电话的地方，调用<br>CallKitManager.shared.startCall(handle: userName, videoEnabled: false)就行啦。。但是有一点需要注意，CallKit只有iOS 10以上支持，所以iOS 10以下的手机还是要支持你们原来打电话的逻辑，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 10.0, *) &#123;</span><br><span class="line">    CallKitManager.shared.startCall(handle:userName, videoEnabled: false)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //原来打电话的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后当你兴冲冲的去用CallKit打电话的时候，却发现弹出的是自己的通话页面。。。T_T<br>但是此时你查看系统的通话记录，应该会发现通话记录里面新增了一条从自己App打出去的记录。这样就说明CallKit拨打电话接入成功了！</p>
<h2 id="接电话"><a href="#接电话" class="headerlink" title="接电话"></a>接电话</h2><p>首先来讲一下如果接电话，来到ProviderDelegate中，添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func reportIncomingCall(uuid: UUID, handle: String, hasVideo: Bool = false, completion: ((Error?) -&gt; Void)?) &#123;</span><br><span class="line">    //准备向系统报告一个 call update 事件，它包含了所有的来电相关的元数据。</span><br><span class="line">    let update = self.callUpdate(handle: handle, hasVideo: hasVideo)</span><br><span class="line">    //调用 CXProvider 的reportIcomingCall(with:update:completion:)方法通知系统有来电。</span><br><span class="line">    provider.reportNewIncomingCall(with: uuid, update: update) &#123; error in</span><br><span class="line">        if error == nil &#123;</span><br><span class="line">            //completion 回调会在系统处理来电时调用。如果没有任何错误，你就创建一个 Call 实例，将它添加到 CallManager 的通话列表。</span><br><span class="line">            let call = Call(uuid: uuid, handle: handle)</span><br><span class="line">            self.callManager.add(call: call)</span><br><span class="line">        &#125;</span><br><span class="line">        //调用 completion，如果它不为空的话。</span><br><span class="line">        completion?(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法需要在所有接电话的地方手动调用，需要根据自己的业务逻辑来判断。还有就是不要忘了iOS的版本兼容哦。。</p>
<p>在ProviderDelegate中实现系统接电话的代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) &#123;</span><br><span class="line">    //从 callManager 中获得一个引用，UUID 指定为要接听的动画的 UUID。</span><br><span class="line">    guard let call = callManager.callWithUUID(uuid: action.callUUID) else &#123;</span><br><span class="line">        action.fail()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //设置通话要用的 audio session 是 App 的责任。系统会以一个较高的优先级来激活这个 session。</span><br><span class="line">    configureAudioSession()</span><br><span class="line">    //通过调用 answer，你会表明这个通话现在激活</span><br><span class="line">    call.answer()</span><br><span class="line">    //在这里添加自己App接电话的逻辑</span><br><span class="line"></span><br><span class="line">    //在处理一个 CXAction 时，重要的一点是，要么你拒绝它（fail），要么满足它（fullfill)。如果处理过程中没有发生错误，你可以调用 fullfill() 表示成功。</span><br><span class="line">    action.fulfill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到AppDelegate中，找到之前写的PushKit收到推送的代理方法，在里面添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType) &#123;</span><br><span class="line">    guard type == .voIP else &#123;</span><br><span class="line">        log.info(&quot;Callkit&amp; pushRegistry didReceiveIncomingPush But Not VoIP&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(&quot;Callkit&amp; pushRegistry didReceiveIncomingPush&quot;)</span><br><span class="line">    //别忘了在这里加上你们自己接电话的逻辑，比如连接聊天服务器啥的，不然这个电话打不通的</span><br><span class="line">    if let uuidString = payload.dictionaryPayload[&quot;UUID&quot;] as? String,</span><br><span class="line">        let handle = payload.dictionaryPayload[&quot;handle&quot;] as? String,</span><br><span class="line">        let hasVideo = payload.dictionaryPayload[&quot;hasVideo&quot;] as? Bool,</span><br><span class="line">        let uuid = UUID(uuidString: uuidString)</span><br><span class="line">    &#123;</span><br><span class="line">        if #available(iOS 10.0, *) &#123;</span><br><span class="line">            ProviderDelegate.shared.reportIncomingCall(uuid: uuid, handle: handle, hasVideo: hasVideo, completion: &#123; (error) in</span><br><span class="line">                if let e = error &#123;</span><br><span class="line">                    log.info(&quot;CallKit&amp; displayIncomingCall Error \(e)&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Fallback on earlier versions</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，CallKit接电话的逻辑完成了，你只需要在合适的地方调用reportIncomingCall就可以调出系统的通话页面了。</p>
<h2 id="挂电话"><a href="#挂电话" class="headerlink" title="挂电话"></a>挂电话</h2><p>来到CallKitManager中，添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func end(call: Call) &#123;</span><br><span class="line">    //先创建一个 CXEndCallAction。将通话的 UUID 传递给构造函数，以便在后面可以识别通话。</span><br><span class="line">    let endCallAction = CXEndCallAction(call: call.uuid)</span><br><span class="line">    //然后将 action 封装成 CXTransaction，以便发送给系统。</span><br><span class="line">    let transaction = CXTransaction(action: endCallAction)</span><br><span class="line">    requestTransaction(transaction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来到ProviderDelegate中，实现系统代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func provider(_ provider: CXProvider, perform action: CXEndCallAction) &#123;</span><br><span class="line">    //从 callManager 获得一个 call 对象。</span><br><span class="line">    guard let call = callManager.callWithUUID(uuid: action.callUUID) else &#123;</span><br><span class="line">        action.fail()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //当 call 即将结束时，停止这次通话的音频处理。</span><br><span class="line">    stopAudio()</span><br><span class="line">    //调用 end() 方法修改本次通话的状态，以允许其他类和新的状态交互。</span><br><span class="line">    call.end()</span><br><span class="line">    //在这里添加自己App挂断电话的逻辑</span><br><span class="line">    //将 action 标记为 fulfill。</span><br><span class="line">    action.fulfill()</span><br><span class="line">    //当你不再需要这个通话时，可以让 callManager 回收它。</span><br><span class="line">    callManager.remove(call: call)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加完之后，只需要在你自己App挂断电话的地方调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 10.0, *) &#123;</span><br><span class="line">    if let call = CallKitManager.shared.calls.first &#123; //因为我们这里不支持群通话，所以一次只有一个call</span><br><span class="line">        CallKitManager.shared.end(call: call)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就可以了。。这里的CallKitManager.shared.calls保存了所有CallKit的通话。是咱们自己写的工具类哦，忘了的话自己翻翻上篇文章。</p>
<p>至此，CallKit挂电话的逻辑结束。。</p>
<h2 id="通话暂时挂起"><a href="#通话暂时挂起" class="headerlink" title="通话暂时挂起"></a>通话暂时挂起</h2><p>来到CallKitManager中，添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func setHeld(call: Call, onHold: Bool) &#123;</span><br><span class="line">    //这个 CXSetHeldCallAction 包含了通话的 UUID 以及保持状态</span><br><span class="line">    let setHeldCallAction = CXSetHeldCallAction(call: call.uuid, onHold: onHold)</span><br><span class="line">    let transaction = CXTransaction()</span><br><span class="line">    transaction.addAction(setHeldCallAction)</span><br><span class="line"></span><br><span class="line">    requestTransaction(transaction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来到ProviderDelegate中，实现系统代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func provider(_ provider: CXProvider, perform action: CXSetHeldCallAction) &#123;</span><br><span class="line">    guard let call = callManager.callWithUUID(uuid: action.callUUID) else &#123;</span><br><span class="line">        action.fail()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //获得 CXCall 对象之后，我们要根据 action 的 isOnHold 属性来设置它的 state。</span><br><span class="line">    call.state = action.isOnHold ? .held:.active</span><br><span class="line">    //根据状态的不同，分别进行启动或停止音频会话。</span><br><span class="line">    if call.state == .held &#123;</span><br><span class="line">        stopAudio()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startAudio()</span><br><span class="line">    &#125;</span><br><span class="line">    //在这里添加你们自己的通话挂起逻辑</span><br><span class="line">    action.fulfill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加完之后，只需要在你自己App通话暂时挂起的地方调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 10.0, *) &#123;</span><br><span class="line">    if let call = CallKitManager.shared.calls.first &#123;</span><br><span class="line">        CallKitManager.shared.setHeld(call: call, onHold: true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就可以了。。</p>
<p>至此，CallKit通话暂时挂起的逻辑结束。。</p>
<h2 id="麦克风静音"><a href="#麦克风静音" class="headerlink" title="麦克风静音"></a>麦克风静音</h2><p>来到CallKitManager中，添加方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func setMute(call: Call, muted: Bool) &#123;</span><br><span class="line">    //CXSetMutedCallAction设置麦克风静音</span><br><span class="line">    let setMuteCallAction = CXSetMutedCallAction(call: call.uuid, muted: muted)</span><br><span class="line">    let transaction = CXTransaction()</span><br><span class="line">    transaction.addAction(setMuteCallAction)</span><br><span class="line">    requestTransaction(transaction)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来到ProviderDelegate中，实现系统代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func provider(_ provider: CXProvider, perform action: CXSetMutedCallAction) &#123;</span><br><span class="line">    guard let call = callManager.callWithUUID(uuid: action.callUUID) else &#123;</span><br><span class="line">        action.fail()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //获得 CXCall 对象之后，我们要根据 action 的 ismuted 属性来设置它的 state。</span><br><span class="line">    call.state = action.isMuted ? .muted : .active</span><br><span class="line">    //在这里添加你们自己的麦克风静音逻辑</span><br><span class="line">    action.fulfill()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加完之后，只需要在你自己App麦克风静音的地方调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 10.0, *) &#123;</span><br><span class="line">    if let call = CallKitManager.shared.calls.first &#123;</span><br><span class="line">        CallKitManager.shared.setMute(call: call, muted: true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就可以了。。</p>
<p>至此，CallKit麦克风静音的逻辑结束。。</p>
<p>到这里，在App内互动的CallKit的基本功能都已经集成完毕，其实到后面大家就能看出来，文章中所有的功能实现，都是先在CallKitManager写用户需要调用的方法，在ProviderDelegate里面实现系统的代理方法，并且加上自己的通话逻辑。</p>
<h2 id="关于系统扬声器与听筒的切换"><a href="#关于系统扬声器与听筒的切换" class="headerlink" title="关于系统扬声器与听筒的切换"></a>关于系统扬声器与听筒的切换</h2><p>这里不讲如何切换扬声器与听筒，只讲如何监听切换，保持App内通话页面免提的状态跟系统通话页面的一致。<br>在自己的通话页面上添加通知监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(forName: NSNotification.Name.AVAudioSessionRouteChange, object: nil, queue: OperationQueue.main) &#123;[weak self] (noti) in</span><br><span class="line">    guard let w = self else &#123; return &#125;</span><br><span class="line">    if #available(iOS 10.0, *) &#123;</span><br><span class="line">        let route = AVAudioSession.sharedInstance().currentRoute</span><br><span class="line">        for desc in route.outputs &#123;</span><br><span class="line">            if desc.portType == &quot;Speaker&quot; &#123;</span><br><span class="line">                // &quot;免提功能已开启&quot;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // &quot;对方已接通，请使用听筒接听&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="从系统通话记录中拨打App电话"><a href="#从系统通话记录中拨打App电话" class="headerlink" title="从系统通话记录中拨打App电话"></a>从系统通话记录中拨打App电话</h2><p>在文章的开头，我们已经导入了Intents.framework，下面开始对他进行操作。<br>首先创建两个协议，目的是为了加几个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protocol StartCallConvertible &#123;</span><br><span class="line">    var startCallHandle: String? &#123; get &#125;</span><br><span class="line">    var video: Bool? &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension StartCallConvertible &#123;</span><br><span class="line">    var video: Bool? &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(iOS 10.0, *)</span><br><span class="line">    protocol SupportedStartCallIntent &#123;</span><br><span class="line">    var contacts: [INPerson]? &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(iOS 10.0, *)</span><br><span class="line">extension INStartAudioCallIntent: SupportedStartCallIntent &#123;&#125;</span><br><span class="line">@available(iOS 10.0, *)</span><br><span class="line">extension INStartVideoCallIntent: SupportedStartCallIntent &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后对NSUserActivity进行扩展，实现StartCallConvertible协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extension NSUserActivity: StartCallConvertible &#123;</span><br><span class="line"></span><br><span class="line">    var startCallHandle: String? &#123;</span><br><span class="line">        if #available(iOS 10.0, *) &#123;</span><br><span class="line">            guard let interaction = interaction,</span><br><span class="line">                    let startCallIntent = interaction.intent as? SupportedStartCallIntent,</span><br><span class="line">                    let contact = startCallIntent.contacts?.first</span><br><span class="line">            else &#123;</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            return contact.personHandle?.value</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var video: Bool? &#123;</span><br><span class="line">        if #available(iOS 10.0, *) &#123;</span><br><span class="line">            guard let interaction = interaction,</span><br><span class="line">                let startCallIntent = interaction.intent as? SupportedStartCallIntent</span><br><span class="line">            else &#123;</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return startCallIntent is INStartVideoCallIntent</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到AppDelegate中，实现代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">override func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool &#123;</span><br><span class="line">    if #available(iOS 10.0, *) &#123;</span><br><span class="line">        guard let handle = userActivity.startCallHandle else &#123;</span><br><span class="line">            log.info(&quot;Callkit&amp; Could not determine start call handle from user activity: \(userActivity)&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        guard let video = userActivity.video else &#123;</span><br><span class="line">            log.info(&quot;Callkit&amp; Could not determine video from user activity: \(userActivity)&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        //如果当前有电话，需要根据自己App的业务逻辑判断</span><br><span class="line"></span><br><span class="line">        //如果没有电话，就打电话，调用自己的打电话方法。</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，从通话记录中调到自己App打电话的功能就实现啦。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Xcode9中的Voice over IP选项]]></title>
      <url>/2018/01/24/42/</url>
      <content type="html"><![CDATA[<p>升级到Xcode9以后，原来的Voice over IP的选项消失了，需要自行去info.plist中添加App provides Voice over IP services。</p>
<a id="more"></a>
<p>升级到Xcode9以后，原来的Voice over IP的选项消失了，需要自行去info.plist中添加App provides Voice over IP services。<br><img src="/2018/01/24/42/20180122153315445.png"><br>另外需要注意的是，升级到Xcode9以后，隐藏了这个选项其实是为了强制大家使用CallKit+PushKit来做VoIP的应用程序。</p>
<p>我们的经验是基于PushKit的VoIP应用程序比那些使用传统VoIP架构的应用程序更可靠，更省电。</p>
<p>Apple始终建议您使用最新版本的Xcode，因为它结合了最佳功能和最佳兼容性。</p>
<p>具体来说，我们鼓励VoIP应用程序充分利用iOS 10 SDK中的新框架CallKit，从根本上改善了VoIP应用程序的用户体验。</p>
<p>另外，请注意，macOS 10.12 Sierra不支持Xcode 7。</p>
<p>在某些时候，对传统VoIP架构的支持将被删除，于是所有的VoIP应用将不得不转移到新的基于PushKit的VoIP架构。</p>
<p>最好早点开始这项工作。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIApplication中文翻译]]></title>
      <url>/2018/01/15/39/</url>
      <content type="html"><![CDATA[<p>UIApplication 类在整个 apps 运行过程中，扮演一个中央处理和协调的工作，任何程序应该只有一个 UIApplication 实例，当一个app 被推出时，系统会调用 UIApplicationMain 函数，在它的其它任务中，这个函数创建了一个单利 UIApplication 对象，此后，你可以调用 shareApplication 方法来获取此对象。</p>
<a id="more"></a>
<p>此外，UIApplication 还处理着用户的触摸事件，分发 action message 到它拥有的合适的目标对象上。应用程序对象维持一个打开的窗口列表，通过这个列表可以检索应用程序的任何 UIView 对象。</p>
<p>UIApplication 定义一个 delegate 对象，遵循 UIApplicationDelegate 协议，AppDelegate而且必须执行某些相关的协议方法。此外，应用程序对象通知这个代理对象一些很重要的运行时候的事件，比如app推出，内存紧张，app 终止等。</p>
<p>应用程序联合处理一些资源，如 email， 图片文件等，通过openURL: 方法，例如一个app调用 eamil url， 通过调用 open URL，可以唤醒 Mail app。</p>
<p>用UIApplication 相关的API可以管理设备的特定行为。如下所示：</p>
<ol>
<li>暂停触摸事件 beginIgnoringInteractionEvents</li>
<li>注册远程推送 unregisterForRemoteNotifications</li>
<li>触发 undo-redo UI applicationSupportsShakeToEdit</li>
<li>确定是否有一个安装程序处理 URL scheme  canOpenURL:</li>
<li>扩展App应用程序的执行，以便它可以在后台完成一个任务beginBackgroundTaskWithExpirationHandler:, beginBackgroundTaskWithName:expirationHandler:</li>
<li>添加和取消本地的通知 scheduleLocalNotification:, cancelLocalNotification:</li>
<li>协调遥控接收事件 beginReceivingRemoteControlEvents, endReceivingRemoteControlEvents</li>
<li>执行app-level状态恢复任务 methods in the Managing the State Restoration Behavior task group</li>
</ol>
<h3 id="获得实例"><a href="#获得实例" class="headerlink" title="获得实例"></a>获得实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 返回应用单个实例</span><br><span class="line">+ (UIApplication *)sharedApplication</span><br></pre></td></tr></table></figure>
<h3 id="获得AppDelegate"><a href="#获得AppDelegate" class="headerlink" title="获得AppDelegate"></a>获得AppDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这个应用的代理</span><br><span class="line">@property(nonatomic, assign) id&lt; UIApplicationDelegate &gt; delegate</span><br></pre></td></tr></table></figure>
<h3 id="获得-app-Windows"><a href="#获得-app-Windows" class="headerlink" title="获得 app Windows"></a>获得 app Windows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readonly) UIWindow *keyWindow</span><br><span class="line">// app的主 window</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly) NSArray &lt;__kindof UIWindow *&gt; *windows</span><br><span class="line">// 隐藏的和看得见的所有 window</span><br></pre></td></tr></table></figure>
<h3 id="控制和处理事件"><a href="#控制和处理事件" class="headerlink" title="控制和处理事件"></a>控制和处理事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendEvent:(UIEvent *)event</span><br><span class="line">// 发送事件给app内适用的响应者</span><br><span class="line"></span><br><span class="line">- (BOOL)sendAction:(SEL)action</span><br><span class="line">to:(id)target</span><br><span class="line">from:(id)sender</span><br><span class="line">forEvent:(UIEvent *)event</span><br><span class="line">// 发送一个含选择器的动作消息到指定的目标</span><br><span class="line"></span><br><span class="line">- (void)beginIgnoringInteractionEvents</span><br><span class="line">// 告诉接受者暂停处理 touch相关的事件</span><br><span class="line"></span><br><span class="line">- (void)endIgnoringInteractionEvents</span><br><span class="line">// 告诉接受者继续处理 touch相关的事件</span><br><span class="line"></span><br><span class="line">- (BOOL)isIgnoringInteractionEvents</span><br><span class="line">// 是否忽略交互事件</span><br><span class="line"></span><br><span class="line">@property(nonatomic) BOOL applicationSupportsShakeToEdit</span><br><span class="line">// 是否接受摇晃的时候， 展现 撤销和恢复 视图</span><br></pre></td></tr></table></figure>
<h3 id="打开URL资源"><a href="#打开URL资源" class="headerlink" title="打开URL资源"></a>打开URL资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)openURL:(NSURL *)url</span><br><span class="line">// 通过特定的URL中打开资源</span><br><span class="line"></span><br><span class="line">- (BOOL)canOpenURL:(NSURL *)url</span><br><span class="line">// 返回一个bool值， 是否从已经安装的 apps 中跳转</span><br></pre></td></tr></table></figure>
<h3 id="配置用户通知设置"><a href="#配置用户通知设置" class="headerlink" title="配置用户通知设置"></a>配置用户通知设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings</span><br><span class="line">// 注册可选的通知</span><br><span class="line"></span><br><span class="line">- (UIUserNotificationSettings *)currentUserNotificationSettings</span><br><span class="line">// 返回关于 user 对于这个app的通知设置</span><br></pre></td></tr></table></figure>
<h3 id="注册远程通知"><a href="#注册远程通知" class="headerlink" title="注册远程通知"></a>注册远程通知</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerForRemoteNotifications</span><br><span class="line">// 注册接受的远程通知，这些通知经由 APNS 发出</span><br><span class="line"></span><br><span class="line">- (void)unregisterForRemoteNotifications</span><br><span class="line">// 注销掉远程通知</span><br><span class="line"></span><br><span class="line">- (BOOL)isRegisteredForRemoteNotifications</span><br><span class="line">// 表明是否已经注册过了远程通知</span><br></pre></td></tr></table></figure>
<h3 id="注册本地通知"><a href="#注册本地通知" class="headerlink" title="注册本地通知"></a>注册本地通知</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)scheduleLocalNotification:(UILocalNotification *)notification</span><br><span class="line">// 安排当地的本地通知，封装了日期和时间</span><br><span class="line"></span><br><span class="line">- (void)presentLocalNotificationNow:(UILocalNotification *)notification</span><br><span class="line">// 立刻弹出本地通知</span><br><span class="line"></span><br><span class="line">- (void)cancelLocalNotification:(UILocalNotification *)notification</span><br><span class="line">// 取消预定的交付的本地通知</span><br><span class="line"></span><br><span class="line">- (void)cancelAllLocalNotifications</span><br><span class="line">// 取消所有的预定的本地通知</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSArray &lt;UILocalNotification *&gt; *scheduledLocalNotifications</span><br><span class="line">// 目前的宿友的预定的本地通知</span><br></pre></td></tr></table></figure>
<h3 id="控制状态恢复"><a href="#控制状态恢复" class="headerlink" title="控制状态恢复"></a>控制状态恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)extendStateRestoration</span><br><span class="line">// 异步恢复状态</span><br><span class="line"></span><br><span class="line">- (void)completeStateRestoration</span><br><span class="line">// 结束异步恢复状态</span><br><span class="line"></span><br><span class="line">- (void)ignoreSnapshotOnNextApplicationLaunch</span><br><span class="line">// 阻止应用程序使用最近的快找图像，在接下来的循环中</span><br><span class="line"></span><br><span class="line">+ (void)registerObjectForStateRestoration:(id&lt;UIStateRestoring&gt;)object</span><br><span class="line">restorationIdentifier:(NSString *)restorationIdentifier</span><br><span class="line">// 注册自定义对象的使用状态恢复系统</span><br></pre></td></tr></table></figure>
<h3 id="控制后台扩展"><a href="#控制后台扩展" class="headerlink" title="控制后台扩展"></a>控制后台扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readonly) UIApplicationState applicationState</span><br><span class="line">// app当前的运行的状态</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly) NSTimeInterval backgroundTimeRemaining</span><br><span class="line">// app 在后台运行的时间</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly) UIBackgroundRefreshStatus backgroundRefreshStatus</span><br><span class="line">// 进入到后台，因此能够进行后台的操作</span><br><span class="line"></span><br><span class="line">- (void)setMinimumBackgroundFetchInterval:(NSTimeInterval)minimumBackgroundFetchInterval</span><br><span class="line">// 指定最小时间间隔在后台获取操作</span><br><span class="line"></span><br><span class="line">- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithName:(NSString *)taskName</span><br><span class="line">expirationHandler:(void (^)(void))handler</span><br><span class="line">// 标记新的长时间运行的任务以及指定任务的命名</span><br><span class="line"></span><br><span class="line">- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void (^)(void))handler</span><br><span class="line">// 标记开始心的长时间运行的后台任务</span><br><span class="line"></span><br><span class="line">- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier</span><br><span class="line">// 结束指定的长时间的后台任务</span><br><span class="line"></span><br><span class="line">@property(nonatomic, getter=isIdleTimerDisabled) BOOL idleTimerDisabled</span><br><span class="line">// 一个bool值 确定控制器是否停止运行在空闲的时间</span><br></pre></td></tr></table></figure>
<h3 id="控制-Home-Screen-和-3D-Touch"><a href="#控制-Home-Screen-和-3D-Touch" class="headerlink" title="控制 Home Screen 和 3D Touch"></a>控制 Home Screen 和 3D Touch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, copy) NSArray &lt;UIApplicationShortcutItem *&gt; *shortcutItems</span><br><span class="line">// 重置此变量，设置一系列的 quick actions 用于3Dtouch展现</span><br></pre></td></tr></table></figure>
<h3 id="注册遥控事件"><a href="#注册遥控事件" class="headerlink" title="注册遥控事件"></a>注册遥控事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginReceivingRemoteControlEvents</span><br><span class="line">// 告诉app 开始接受遥控事件</span><br><span class="line"></span><br><span class="line">- (void)endReceivingRemoteControlEvents</span><br><span class="line">// 告诉app 结束接受遥控事件</span><br></pre></td></tr></table></figure>
<h3 id="控制应用程序外观"><a href="#控制应用程序外观" class="headerlink" title="控制应用程序外观"></a>控制应用程序外观</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readonly) CGRect statusBarFrame</span><br><span class="line">// 获取状态栏的 rect</span><br><span class="line"></span><br><span class="line">@property(nonatomic, getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible</span><br><span class="line">// 是否指示网络活动，默认是NO</span><br><span class="line"></span><br><span class="line">@property(nonatomic) NSInteger applicationIconBadgeNumber</span><br><span class="line">// 未读消息数字</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly) UIUserInterfaceLayoutDirection userInterfaceLayoutDirection</span><br><span class="line">// 返回用户界面的布局方向。</span><br></pre></td></tr></table></figure>
<h3 id="控制默认的方向"><a href="#控制默认的方向" class="headerlink" title="控制默认的方向"></a>控制默认的方向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientationsForWindow:(UIWindow *)window</span><br><span class="line">// 在指定的窗口中， 返回默认的视图控制器方向接口</span><br></pre></td></tr></table></figure>
<h3 id="控制状态栏方向"><a href="#控制状态栏方向" class="headerlink" title="控制状态栏方向"></a>控制状态栏方向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readonly) NSTimeInterval statusBarOrientationAnimationDuration</span><br><span class="line">// 状态栏动画持续时间</span><br></pre></td></tr></table></figure>
<h3 id="字体大小偏好"><a href="#字体大小偏好" class="headerlink" title="字体大小偏好"></a>字体大小偏好</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, readonly) NSString *preferredContentSizeCategory</span><br><span class="line">// 字体偏好</span><br></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">UIBackgroundTaskIdentifier;</span><br><span class="line">// 一个独特的标志，这个标志用于在后台请求运行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIRemoteNotificationType</span><br><span class="line">// 指示应用程序的通知类型</span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">UIRemoteNotificationTypeNone    = 0,</span><br><span class="line">UIRemoteNotificationTypeBadge   = 1 &lt;&lt; 0,</span><br><span class="line">UIRemoteNotificationTypeSound   = 1 &lt;&lt; 1,</span><br><span class="line">UIRemoteNotificationTypeAlert   = 1 &lt;&lt; 2,</span><br><span class="line">UIRemoteNotificationTypeNewsstandContentAvailability = 1 &lt;&lt; 3</span><br><span class="line">&#125; UIRemoteNotificationType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIStatusBarStyle</span><br><span class="line">// 状态栏的样式</span><br><span class="line">typedef enum : NSInteger &#123;</span><br><span class="line">UIStatusBarStyleDefault,         // 黑色状态，用于白背景</span><br><span class="line">UIStatusBarStyleLightContent,    // light 状态， 用于dark 背景</span><br><span class="line"></span><br><span class="line">UIStatusBarStyleBlackTranslucent, // 7.0 弃用</span><br><span class="line">UIStatusBarStyleBlackOpaque       // 7.0 弃用</span><br><span class="line">&#125; UIStatusBarStyle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIStatusBarAnimation</span><br><span class="line">// 在状态栏隐藏于显现之间的动画</span><br><span class="line">typedef enum : NSInteger &#123;</span><br><span class="line">UIStatusBarAnimationNone,</span><br><span class="line">UIStatusBarAnimationFade,</span><br><span class="line">UIStatusBarAnimationSlide,</span><br><span class="line">&#125; UIStatusBarAnimation;</span><br></pre></td></tr></table></figure>
<h3 id="常量-Constants"><a href="#常量-Constants" class="headerlink" title="常量(Constants)"></a>常量(Constants)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">UIApplicationState  // 应用状态</span><br><span class="line">typedef enum : NSInteger &#123;</span><br><span class="line">UIApplicationStateActive,</span><br><span class="line">UIApplicationStateInactive,</span><br><span class="line">UIApplicationStateBackground</span><br><span class="line">&#125; UIApplicationState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在后台运行时候常用的常量</span><br><span class="line">const UIBackgroundTaskIdentifier UIBackgroundTaskInvalid;</span><br><span class="line">// 无效的后台任务</span><br><span class="line">const NSTimeInterval UIMinimumKeepAliveTimeout;</span><br><span class="line">// 后台保持的最小的时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIBackgroundFetchResult</span><br><span class="line">// 后台请求结果</span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">UIBackgroundFetchResultNewData,</span><br><span class="line">UIBackgroundFetchResultNoData,</span><br><span class="line">UIBackgroundFetchResultFailed</span><br><span class="line">&#125; UIBackgroundFetchResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fetch Intervals</span><br><span class="line">// 请求间隔</span><br><span class="line">const NSTimeInterval UIApplicationBackgroundFetchIntervalMinimum; // 系统支持的最小的间隔</span><br><span class="line">const NSTimeInterval UIApplicationBackgroundFetchIntervalNever;   // 最大间隔， 以阻止请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIBackgroundRefreshStatus</span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">UIBackgroundRefreshStatusRestricted,  // 限制</span><br><span class="line">UIBackgroundRefreshStatusDenied,      // 否定</span><br><span class="line">UIBackgroundRefreshStatusAvailable    // 可用</span><br><span class="line">&#125; UIBackgroundRefreshStatus;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIInterfaceOrientation</span><br><span class="line">// 应用程序的用户界面方向</span><br><span class="line">typedef enum : NSInteger &#123;</span><br><span class="line">UIInterfaceOrientationUnknown            = UIDeviceOrientationUnknown,</span><br><span class="line">UIInterfaceOrientationPortrait           = UIDeviceOrientationPortrait,</span><br><span class="line">UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown,</span><br><span class="line">UIInterfaceOrientationLandscapeLeft      = UIDeviceOrientationLandscapeRight,</span><br><span class="line">UIInterfaceOrientationLandscapeRight     = UIDeviceOrientationLandscapeLeft</span><br><span class="line">&#125; UIInterfaceOrientation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIInterfaceOrientationMask</span><br><span class="line">// 指定一个视图控制器支持的接口方向。</span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait ),</span><br><span class="line">UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft ),</span><br><span class="line">UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight ),</span><br><span class="line">UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown ),</span><br><span class="line">UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight ),</span><br><span class="line">UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft |</span><br><span class="line">UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown ),</span><br><span class="line">UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft |</span><br><span class="line">UIInterfaceOrientationMaskLandscapeRight ),</span><br><span class="line">&#125; UIInterfaceOrientationMask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UserInfo Dictionary Keys</span><br><span class="line">// 这些键值用来接受用户信息字典，用于访问值一些UIApplication-posted通知。</span><br><span class="line">NSString *const UIApplicationStatusBarOrientationUserInfoKey;</span><br><span class="line">NSString *const UIApplicationStatusBarFrameUserInfoKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Content Size Category Constants // 内容大笑类别常量</span><br><span class="line">NSString *const UIContentSizeCategoryExtraSmall;</span><br><span class="line">NSString *const UIContentSizeCategorySmall;</span><br><span class="line">NSString *const UIContentSizeCategoryMedium;</span><br><span class="line">NSString *const UIContentSizeCategoryLarge;</span><br><span class="line">NSString *const UIContentSizeCategoryExtraLarge;</span><br><span class="line">NSString *const UIContentSizeCategoryExtraExtraLarge;</span><br><span class="line">NSString *const UIContentSizeCategoryExtraExtraExtraLarge;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 内容尺寸改变的通知的key</span><br><span class="line">NSString *const UIContentSizeCategoryNewValueKey;</span><br></pre></td></tr></table></figure>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">UIApplicationBackgroundRefreshStatusDidChangeNotification</span><br><span class="line">// 在后台下载内容的应用程序的状态变化时候通知</span><br><span class="line"></span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line">// 当程序变的活跃之后</span><br><span class="line"></span><br><span class="line">UIApplicationDidChangeStatusBarFrameNotification</span><br><span class="line">// 当状态栏frame 改变时候</span><br><span class="line"></span><br><span class="line">UIApplicationDidChangeStatusBarOrientationNotification</span><br><span class="line">// 当用户方向改变时候</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIApplicationDidEnterBackgroundNotification</span><br><span class="line">// 当app已经进入后台之后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UIApplicationDidFinishLaunchingNotification</span><br><span class="line">// 当app完全推出之后</span><br><span class="line"></span><br><span class="line">UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">// 当应用内存紧张之后</span><br><span class="line"></span><br><span class="line">UIApplicationProtectedDataDidBecomeAvailable</span><br><span class="line">// 但受保护的文件进入活跃状态</span><br><span class="line"></span><br><span class="line">UIApplicationProtectedDataWillBecomeUnavailable</span><br><span class="line">// 当被保护的文件进入不活跃状态</span><br><span class="line"></span><br><span class="line">UIApplicationUserDidTakeScreenshotNotification</span><br><span class="line">// 当截屏的时候</span><br><span class="line"></span><br><span class="line">UIApplicationWillChangeStatusBarOrientationNotification</span><br><span class="line">// 当应用程序将要改变其接口方向</span><br><span class="line"></span><br><span class="line">UIApplicationWillChangeStatusBarFrameNotification</span><br><span class="line">// 当应用将要改变状态来frame</span><br><span class="line"></span><br><span class="line">UIApplicationWillEnterForegroundNotification</span><br><span class="line">// 当应用程序从后台将要进入前台</span><br><span class="line"></span><br><span class="line">UIApplicationWillResignActiveNotification</span><br><span class="line">// 应用程序不再主动和失去焦点。</span><br><span class="line"></span><br><span class="line">UIApplicationWillTerminateNotification</span><br><span class="line">// 当应用程序将要终止。</span><br><span class="line"></span><br><span class="line">UIContentSizeCategoryDidChangeNotification</span><br><span class="line">// 当用户更改内容大小的偏好设置</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pod install速度慢的终极解决方案]]></title>
      <url>/2018/01/11/37/</url>
      <content type="html"><![CDATA[<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题</p>
<a id="more"></a>
<ol>
<li>使用国内镜像的Specs</li>
<li>在pod install时使用命令pod install –no-repo-update</li>
<li>使用proxychains使终端命令走代理</li>
</ol>
<p>下面就来说明一下这几种方法为何没有完全解决问题</p>
<h4 id="使用国内镜像的Specs"><a href="#使用国内镜像的Specs" class="headerlink" title="使用国内镜像的Specs"></a>使用国内镜像的Specs</h4><p>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p>
<h4 id="在pod-install时使用命令pod-install-–no-repo-update"><a href="#在pod-install时使用命令pod-install-–no-repo-update" class="headerlink" title="在pod install时使用命令pod install –no-repo-update"></a>在pod install时使用命令pod install –no-repo-update</h4><p>install时不更新本地库，但如果第一次install还是要去github clone代码</p>
<h4 id="使用proxychains使终端命令走代理"><a href="#使用proxychains使终端命令走代理" class="headerlink" title="使用proxychains使终端命令走代理"></a>使用proxychains使终端命令走代理</h4><p>这个只是使pod命令走代理，git download的时候不会走代理</p>
<p>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。<br>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure></p>
<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure></p>
<p>如此就从根本上解决了问题</p>
]]></content>
      
        
        <tags>
            
            <tag> CocoaPod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 应用程序挂起、复原与终止]]></title>
      <url>/2018/01/10/40/</url>
      <content type="html"><![CDATA[<p>当有电话进来或者锁屏，这时你的应用程会挂起，在这时，UIApplicationDelegate委托会收到通知，调用 applicationWillResignActive 方法，你可以重写这个方法，做挂起前的工作，比如关闭网络，保存数据。<br><a id="more"></a></p>
<h2 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h2><p>当有电话进来或者锁屏，这时你的应用程会挂起，在这时，UIApplicationDelegate委托会收到通知，调用 applicationWillResignActive 方法，你可以重写这个方法，做挂起前的工作，比如关闭网络，保存数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillResignActive:(UIApplication*)application&#123;</span><br><span class="line">/*添加你自己的挂起前准备代码*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="复原"><a href="#复原" class="headerlink" title="复原"></a>复原</h2><p>当程序复原时，另一个名为 applicationDidBecomeActive 委托方法会被调用，在此你可以通过之前挂起前保存的数据来恢复你的应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidBecomeActive:(UIApplication*)application&#123;</span><br><span class="line">/*添加你的恢复代码*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：应用程序在启动时，在调用了 applicationDidFinishLaunching 方法之后也会调用 applicationDidBecomeActive 方法，所以你要确保你的代码能够分清复原与启动，避免出现逻辑上的bug。</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>当用户按下按钮，或者关机，程序都会被终止。当一个程序将要正常终止时会调用 applicationWillTerminate 方法。但是如果长主按钮强制退出，则不会调用该方法。这个方法该执行剩下的清理工作，比如所有的连接都能正常关闭，并在程序退出前执行任何其他的必要的工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillTerminate:(UIApplication*)application&#123;</span><br><span class="line">/*在这里添加退出前的清理代码以及其他工作代码*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n ===&gt; 程序开始 !&quot;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n ===&gt; 程序暂行 !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n ===&gt; 程序进入后台 !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n ===&gt; 程序进入前台 !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n ===&gt; 程序重新激活 !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;\n ===&gt; 程序意外暂行 !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="首次运行："><a href="#首次运行：" class="headerlink" title="首次运行："></a>首次运行：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br></pre></td></tr></table></figure>
<h3 id="首次关闭（home）："><a href="#首次关闭（home）：" class="headerlink" title="首次关闭（home）："></a>首次关闭（home）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br></pre></td></tr></table></figure>
<h3 id="再次运行："><a href="#再次运行：" class="headerlink" title="再次运行："></a>再次运行：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br></pre></td></tr></table></figure>
<h3 id="再次关闭："><a href="#再次关闭：" class="headerlink" title="再次关闭："></a>再次关闭：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 后台任务]]></title>
      <url>/2018/01/05/41/</url>
      <content type="html"><![CDATA[<p>iOS提供了以下多中方式处理后台任务</p>
<ol>
<li>beginBackgroundTaskWithExpirationHandler</li>
<li>特定任务的后台处理</li>
<li>后台获取</li>
<li>推送唤醒</li>
<li>后台传输</li>
</ol>
<a id="more"></a>
<h2 id="beginBackgroundTaskWithExpirationHandler"><a href="#beginBackgroundTaskWithExpirationHandler" class="headerlink" title="beginBackgroundTaskWithExpirationHandler"></a>beginBackgroundTaskWithExpirationHandler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    _count = 0;</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(function) userInfo:nil repeats:YES];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">-(void)function &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    NSLog(@&quot;function：%d&quot;,_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码开启了一个定时器，每隔一秒输出count的值，但当我们的应用退到前台后定时器停止运行，我们可以通过函数beginBackgroundTaskWithExpirationHandler向系统请求更多地时间运行我们的代码，这个”更多的时间”经过测试大概在3分钟左右。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    _count = 0;</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(function) userInfo:nil repeats:YES];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">-(void)function &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    NSLog(@&quot;function：%d&quot;,_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    _identifier = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">    [application endBackgroundTask:_identifier];</span><br><span class="line">        _identifier = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_identifier是整型变量，beginBackgroundTaskWithExpirationHandler设置了一个超时回调函数，当超过3分钟后后台任务将被挂起同时执行超时函数，我们应该在超时函数中调用endBackgroundTask，下面代码展示了beginBackgroundTaskWithExpirationHandler更一般的调用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginBackgroundTask &#123;</span><br><span class="line">    UIApplication *application = [UIApplication sharedApplication];</span><br><span class="line">    _identifier = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        [self endBackgroundTask];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)endBackgroundTask &#123;</span><br><span class="line">    UIApplication *application = [UIApplication sharedApplication];</span><br><span class="line">    [application endBackgroundTask:_identifier];</span><br><span class="line">    _identifier = UIBackgroundTaskInvalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [self beginBackgroundTask];</span><br><span class="line">    //后台任务</span><br><span class="line">    do something;</span><br><span class="line">    [self endBackgroundTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="后台获取"><a href="#后台获取" class="headerlink" title="后台获取"></a>后台获取</h2><p>后台获取是iOS7新增内容，它的核心作用是设定一个间隔，然后每隔一段时间唤醒应用处理相应地任务，比如我们使用的社交软件，可以每个一定时间获取最新的信息，这样下次我们进入后就不需要等待刷新，使用后台获取的步骤如下：</p>
<ol>
<li>添加应用对后台获取的支持，可以在plist文件中修改UIBackgroundMode一项，增加fetch，或者在应用信息的capabilities-&gt;background modes中勾选background fetch</li>
<li>设置最小后台获取时间间隔</li>
<li>实现application:performFetchWithCompletionHandler</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不设置的话默认为UIApplicationBackgroundFetchIntervalNever，表示不获取，而且这个值代表”最小”后台获取时间间隔，这里所指定的时间间隔只是代表了“在上一次获取或者关闭应用之后，在这一段时间内一定不会去做后台获取”，IOS并不会为了每一个应用频频唤醒CPU，具体唤醒时间得看系统调度，设置为UIApplicationBackgroundFetchIntervalMinimum表示尽可能的对我们的应用进行后台唤醒，这样设置的缺点是耗电。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler &#123;</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://blog.csdn.net/paradiseduo/article/details/79063224&quot;]];</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;,[error localizedDescription]);</span><br><span class="line">            completionHandler(UIBackgroundFetchResultFailed);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ////更新UI</span><br><span class="line">            NSLog(@&quot;%@&quot;,[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">            completionHandler(UIBackgroundFetchResultNewData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与beginBackgroundTaskWithExpirationHandler相似，系统提供了回调completionHandler，用于通知系统任务执行完毕。</p>
<h2 id="推送唤醒"><a href="#推送唤醒" class="headerlink" title="推送唤醒"></a>推送唤醒</h2><ol>
<li>在UIBackgroundModes添加remote-notification</li>
<li>更改推送的payload：需要在payload中添加content-available，并设置为1</li>
<li>实现推送唤醒代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>代码实现与上一种方式一致，任务实现完需要调用回调方法通知系统</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈Xcode下的绝对路径和相对路径]]></title>
      <url>/2018/01/01/38/</url>
      <content type="html"><![CDATA[<p>一般我们在xcode中添加头文件，或者添加pch文件时候，这时候就需要用到相对路径和绝对路径这两个概念了。<br><a id="more"></a><br>首先我们需要简单了解一下什么是绝对路径和相对路径。相对路径实际就是调用当前目录下面的文件，绝对路径跟相对路径一样调用文件，但绝对路径是一个固定地址。<br>简单举个例子介绍一下，例如我在桌面建一个aa的文件夹，里面一个index.html，再建一个Image文件夹，放一张图片为image1.jpg<br>例：</p>
<ol>
<li>绝对路径：C:\Administrator\桌面\aa\image\image1.jpg</li>
<li>相对路径：aa/Image/image1.jpg</li>
</ol>
<p>绝对路径寻找方法:点击工程某个文件，右键“show in finder”打开终端，cd 把文件夹拖入，即可出现一个路径，这个就是绝对路径</p>
<p>相对路径即相对于当前工程文件的路径，“./”表示当前工程文件夹，后面接得全部是真实文件夹名，工程内部的group无效，”../“表示上层目录 ,在xcode里“$(PROJECT_DIR)”也表示当前工程文件夹目录</p>
<p>这里还要了解一下在iOS中怎么代表相对路径和绝对路劲</p>
<ol>
<li>$(SRCROOT)代表的是项目根目录下</li>
<li>$(PROJECT_DIR)代表的是当前工程文件夹目录,也就是整个项目</li>
</ol>
<p>一般在实际开发中，都是用的相对路径，除非是自己做项目，项目位置不变动。否则代码就是用相对路径，这样就不会害怕项目的位置变动了或者发给别人开发。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS应用剖析 ---- Data目录]]></title>
      <url>/2017/12/20/36/</url>
      <content type="html"><![CDATA[<p>Data目录中最重要的是Application子目录。<br><a id="more"></a><br>Data/Applications目录包含了应用程序运行所需的其他数据：参数设置，缓存，cookie等。这个目录也是需要重点检查的对象。因为大部分数据泄露都发生在这里。下面我来深入的介绍一下这些子目录，当然，目录树中的目录不一定会全部出现在应用的目录中，有一些是使用特定的API创建的。</p>
<h3 id="Documents和Inbox目录"><a href="#Documents和Inbox目录" class="headerlink" title="Documents和Inbox目录"></a>Documents和Inbox目录</h3><p>Documents目录主要用来存储非临时状态的应用数据，比如用户创建的内容或应用程序在离线模式下需要的本地缓存信息。 如果你在应用的Info.plist文件中设置了UIFileSharingEnabled，那么可以通过iTunes访问这些文件。</p>
<p>其他应用发送过来的文件储存在Documents/Index目录中。这些应用可以使用UIDocumentInteractionController类来发送文件。</p>
<p>你只能读取和删除存储在Inbox目录下的文件。这些来自于其他应用程序的文件不能写入你的应用目录里，他们将被一个优先级更高的系统进程处理。 你可以定期删除这些文件也可以让用户选择是否删除，这样用户就可以知道这里有没有敏感信息。</p>
<p>如果你正在开发一个应用想确保磁盘上不会遗留任何敏感信息，那么可以将Inbox目录中的文档复制到另外一个位置，从而对数据进行保护，然后从Inbox目录中移除这些文件。</p>
<p>注意，你的应用程序请求打开的任意文件都有可能永久的遗留在磁盘中。如果你尝试打开一个应用程序无法处理的文件类型，那么这个文件将会被传递给第三方应用，我们无法知道第三方应用是否会将它删除或者也许会将文件永久保留下来。换句话说，你无法清理那些要求第三方应用打开的文件即使只是用Quick Look API来简单预览一下内容。Inbox文件在外面存放太长时间很危险，应该考虑让你的应用能够查看自己的数据，而不是依赖一个帮手，你保证最后正确的清除这些文件。</p>
<h3 id="Library目录"><a href="#Library目录" class="headerlink" title="Library目录"></a>Library目录</h3><p>Library目录包含应用程序相关的大部分文件包括由应用程序和网络产生的缓存数据。Library目录下的文件可以通过iTunes和iCloud进行备份，Cache目录除外。</p>
<h3 id="Application-Support目录"><a href="#Application-Support目录" class="headerlink" title="Application Support目录"></a>Application Support目录</h3><p>由用户创建和接受的文件不会储存在Application Support目录中，该目录主要用来存储应用程序使用的数据文件。例如，一个应用程序内购买的下载内容，配置文件，积分榜等。正如它名字所暗示的那样，该目录下的文件，主要用来支持应用程序运行，这些文件可以在应用程序安装时不熟也可以由应用程序创建或从网络上下载。</p>
<p>默认情况下iiTunes会备份这个目录下的数据到你的计算机和iCloud中。但是如果你不放心将数据保存在苹果的云端也可以通过为新创建的文件设置NSURLIsExcludedFromBackupKey属性来禁止备份到云端。</p>
<p>值得注意的是，苹果只要求应用备份用户数据到iCloud，包括用户创建的文档配置文件等，不要求应用程序备份数据。如果一个应用程序，允许将应用相关的内容备份到iCloud上，比如可下载内容，那么该应用，一定会被App Store拒绝上架。</p>
<h3 id="Caches和Snapshots目录"><a href="#Caches和Snapshots目录" class="headerlink" title="Caches和Snapshots目录"></a>Caches和Snapshots目录</h3><p>Caches目录在功能上类似网页浏览器的缓存：应用程序保留数据的主要目的是为了性能，而不是因为数据本身很重要。所以iTunes不会备份此目录。</p>
<p>虽然苹果声明应该由你的应用程序管理Caches目录但是操作系统，其实也会操作该目录下的内容和子文件夹Snapshots。我们应该形成一种思维定式：Caches目录用来存放临时内容，伴随着应用程序的启动与退出，这些内容将会被丢弃。iOS在系统运行空间不足时也会自动删除这些话传目录，不过并不会删除当前正在运行程序的缓存。</p>
<p>Caches目录有时也会把网页缓存内容存储在子目录Caches/com.mycompany.myapp</p>
<p>中。该位置也容易泄露敏感信息，因为通过https进行长时间传输数据可以被iOS缓存。如果开发者没有禁止数据缓存和尽快使缓存数据过期，那么攻击者总能在这里尝到甜头。</p>
<p>最后，当应用程序，进入后台操作系统会自动把当前应用的屏幕快照存储在Snapshots子目录中，这样做会无形中把一些敏感信息存储在本地。操作系统的初衷是好的：应用被切回前台时操作系统可以使它的屏幕快照创建一个快速的动画。不幸的是，在很多应用中经常看到由此产生的副作用：截图中包含了用户的社会保险号码，用户的详细信息以及其他敏感内容。</p>
<h3 id="Cookies目录"><a href="#Cookies目录" class="headerlink" title="Cookies目录"></a>Cookies目录</h3><p>由URL加载系统所产生的Cookie都存储在Cookies目录中。创建NSURLRequest请求时，你将指定相关的Cookie策略，或者选择系统默认的策略。和OS X不同，iOS上的Cookie不会在应用程序之间共享，每个应用都有单独的目录来存储自己的Cookie。</p>
<h3 id="Preferences目录"><a href="#Preferences目录" class="headerlink" title="Preferences目录"></a>Preferences目录</h3><p>iOS将应用的偏好设置存储在Preferences目录下，但是不允许应用，直接编辑目录中的文件。 取而代之，此目录下文件的创建，读取和操作都通过NSUserDefaults或CFPreferences API来完成。</p>
<p>这些API将应用设置文件已传文本的格式存储，因此绝不能用它们来存储敏感的用户信息和证书。审查一个应用的本地存储信息时一定要记得检查Preference目录中的plist文件。有时候你会在这些plist文件中，发现用户名和密码API访问密钥和不应该暴露给用户的安全设置。</p>
<h3 id="保存应用程序状态的目录"><a href="#保存应用程序状态的目录" class="headerlink" title="保存应用程序状态的目录"></a>保存应用程序状态的目录</h3><p>用户期待应用能够记住他们输入文本框的内容和启用的设置。如果一个用户切换到另外一个应用，片刻后又切回之前的应用，原先的应用可能已经在后台被操作系统杀掉了。为了在应用启动时使它的界面和之前保持一致，新版本的iOS通过State Preservation API将对象状态信息存储在Saved Application State目录中。开发者可以将需要保存状态的UI标记出来。</p>
<h3 id="tmp目录"><a href="#tmp目录" class="headerlink" title="tmp目录"></a>tmp目录</h3><p>正如你猜测的那样，tmp用来存储临时文件。和Caches目录一样，当你的应用程序停止运行时，该目录中包含的文件可能会被操作系统自动删除。此目录的使用方法与Caches目录类似，不同之处在于Caches意味着缓存的这些文件可能会被再次获取和重新创建。比如，你从远程服务器下载了特定的应用数据，然后为了提高性能，会将数据缓存在Caches中，如果输就消失了，可以重新去下载。另一方面tmp严格存储着由应用产生的临时数据，也就是说如果这些文件在重新访问前被删除，你并不能重新获取到他们。此外，和Caches目录一样，tmp也不会被分到iTunes或iCloud中。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Mac终端编写、编译C程序]]></title>
      <url>/2017/12/19/35/</url>
      <content type="html"><![CDATA[<p>在没有编写C语言IDE的情况下，我们可以通过Mac的终端对C语言进行编写与编译。<br><a id="more"></a><br>步骤：创建C文件、用Vim编写C程序、编译C程序文件、执行编译后生成的.out文件。</p>
<ol>
<li><p>$:touch Hello.c               //创建一个Hello.c文件（本目录下）</p>
</li>
<li><p>$:vim Hello.c                  //用vim编辑Hello.c文件</p>
</li>
</ol>
<p>输入 i                                   //打开vim后先输入i进入编辑状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(“Hello Mac ! \n”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ESC键                      //按ESC键退出编辑状态<br>:wq                           //先输入“:”，再输入“w”表示保存，最后输入“q”表示退出</p>
<ol>
<li><p>$:gcc Hello.c             //编译Hello.c文件，会生成可执行文件“a.out”</p>
</li>
<li><p>$:./a.out                    //执行a.out</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS应用剖析 ---- 设备目录]]></title>
      <url>/2017/12/19/34/</url>
      <content type="html"><![CDATA[<p>从iOS8开始，模拟器平台（比如iPhone、iPad以及其他的变体设备）都存储在以唯一标识符命名的目录下。这些标识符由两部分组成：一部分是从Xcode启动模拟器时选择的设备类型，另一部分是系统版本。所有目录都有一个plist文件记录当前的设备信息。</p>
<a id="more"></a>
<p>在这个plist文件中，想找出设备信息并不容易。为了找出设备信息，要么去Devices目录下查看.default_created.plist文件，要么使用grep命令找出所有的device.plist文件。<br>打开终端，输入(这里举例子，具体路径还要根据自己的电脑酌情改变)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd /User/me/Library/Developer/CoreSimulator/Devices &amp;&amp; ls</span><br><span class="line"></span><br><span class="line">$ for dir in &apos;ls|grep -v default&apos;</span><br><span class="line">do</span><br><span class="line">echo $dir</span><br><span class="line">grep -Cl name $dir/device.plist |tail -l|sed -e &apos;s/&lt;/\*string&gt;//g&apos;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>进入正在运行的应用程序目录后，你会看到data目录，它包含所有的模拟器文件，还包括应用的相关数据。应用数据被分别放到了三个目录中，他们在data/Containers目录下，分别是Bundle、Data和Shared目录。<br>这篇文章主要介绍一下Bundle和Shared目录，关于Data目录内容较多，下一篇文章单独介绍。</p>
<h3 id="Bundle目录"><a href="#Bundle目录" class="headerlink" title="Bundle目录"></a>Bundle目录</h3><p>Bundle目录中有一个Applications目录，该目录包含设备上的所有的应用目录，这些应用目录用应用程序的bundle ID命名。</p>
<p>在应用目录中，.app文件夹存储应用程序的核心二进制代码、图像资源、本地化信息等；info.plist文件包含应用程序的核心配置信息，包括bundle标识、主程序包、应用程序的UI信息以及应用程序需要向设备请求的功能。</p>
<p>在文件系统中，这些plist会以XML或二进制格式进行存储，后者通常是默认的存储方式。你可以通过代码的方式获取info.plist中的信息，及引用[NSBundle mainBundle]中的字典属性；一般通过这种方式来载入一些样式或本地化信息。</p>
<p>info.plist文件中值得我们关注的条目是UIRequiredDeviceCapabilities，他看上去像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIRequiredDeviceCapabilities&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;armv7&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;location-services&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;sms&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>
<p>UIRequiredDeviceCapabilities描述了应用所需要的系统资源。<br>虽然这不是强制要求的，但还是暗示了这个应用将涉及哪些活动类型。</p>
<h3 id="Shared目录"><a href="#Shared目录" class="headerlink" title="Shared目录"></a>Shared目录</h3><p>Shared目录是一个特殊的目录，用来为应用程序提供一个共享的应用组(为了支持iOS8的扩展extensions)，比如通知中心的“今日”视图中的任务或键盘行为，widget。苹果要求所有的扩展必须对应一个容器应用，每一个容器应用会拥有自己的应用ID。扩展及其应用容器可以通过Shared目录来共享数据。</p>
<p>例如，用户可以使用NSUserDefaults的初始化方法，制定一个名字来访问用户数据中共享的数据库。</p>
<p>Shared目录不常用，但是当我们检查存储在perferences中的敏感信息或其他隐私数据时，别忘了它。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS应用剖析 ---- 对plist文件进行处理]]></title>
      <url>/2017/12/18/28/</url>
      <content type="html"><![CDATA[<p>想要理解iOS应用所面临的某些问题，最好能熟知应用如何存储和操作私有目录下的各种数据，包括配置文件、资源文件、二进制我呢间以及文档。在这里你会发现各种信息的泄露方式，同时也能深入理解应用程序的核心。<br><a id="more"></a><br>要找出应用在本地存储的所有数据，最快的方法是查看~/Library/Developer/CoreSimulator/Devices目录。从Xcode6开始，只要在模拟器上运行过的应用，Xcode都会根据当前设备类型和系统版本建立一个文件夹并分配一个UUID。相关应用的数据也会被存储在这里。其中应用的二进制和资源文件(包括.nib文件和图形文件)都放置在<device id="">/data/Containers/Bundle/Application/<app bundleid="">目录下。而经常变化的动态数据则存储在~<device id="">/data/Containers/Data/Application/<app bundleid="">目录中。系统数据(如全局配置文件)将存储在其余的目录下。</app></device></app></device></p>
<p>如果你的设备已经越狱，那么你可以使用SSH连接到设备，并研究一下它的目录结构。但是你也可以使用iExplorer这样的工具来查看和安装应用程序的目录结构，不论你越狱与否。</p>
<h3 id="对plist文件进行处理："><a href="#对plist文件进行处理：" class="headerlink" title="对plist文件进行处理："></a>对plist文件进行处理：</h3><p>iOS将应用程序的配置数据存储在属性列表(plist)文件里，这些信息都是CoreFoundation数据类型，比如CFArray和CFString。从安全角度来说，你需要重点检查plist文件中不是纯文本的值，比如证书，他们有可能会被修改从而改变应用程序的行为。</p>
<p>举个例子：默认情况下支付功能是金庸的，但是当相应的值被修改时，该功能就可使用。</p>
<p>属性列表有两种格式：二进制和XML。XML文件具有良好的可读性。其中的配置文件里存储了程序的基本信息，包括该应用能够运行的平台，代码签名等(在模拟器上运行的程序是不会显示代码签名的)</p>
<p>如果用命令行查看文件或在代码中处理plist，就会经常遇到二进制格式的plist文件。二进制文件的可读性与可写性就不是那么理想了，但是你可以使用plutil(1)命令将plist文件转换成XML格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ plutil -convert xml1 Info.plist -o -</span><br><span class="line">$ plutil -convert xml1 Info.plist -o Info-xml.plist</span><br><span class="line">$ plutil -convert binary1 Info-xml.plist -o Info-bin.plist</span><br></pre></td></tr></table></figure></p>
<p>第一条命令将一个二进制的plist转换成XML，然后打印到标准输出(stdout)，之后可以通过管道(pipe)把内容传给less(1)或者类似的命令。当然你也可以向第二条命令那样，使用-o filename参数直接将内容输出到一个文件。第三条命令，binary1转换类型，将XML格式的plist转换为二进制格式。不过两种格式系统都能识别，所以一般不做转换。</p>
<p>为了无缝读取和编辑plist，可以提前配置好你的文本编辑器，使其在读写plist文件的时候自动转换。。你可以在你所熟悉的环境里配置，比如你习惯用Vim，那么就可以在.vimrc配置文件中添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">command -bar PlistXML :set binary | :1,$!plutil -convert xml1 /dev/stdin -o -</span><br><span class="line">command -bar Plistbbin :1,$!plutil -convert binary1 /dev/stdin -o -</span><br><span class="line"></span><br><span class="line">func ReadPlist()</span><br><span class="line">    if getline(&quot;&apos;[&quot;) =~ &quot;^bplist&quot;</span><br><span class="line">        :PlistXML</span><br><span class="line">        set filetype=xml</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">augroup misc</span><br><span class="line">au BufWinEnter *.plist, call ReadPlist()</span><br><span class="line">augroup end</span><br></pre></td></tr></table></figure></p>
<p>这个配置使用:PlistXML命令自动将需要编辑的二进制格式plist转换为XML文件，从而在肉眼可读的情况下对文件进行修改。当我们准备将这些修改保存到文件中时，改文件将再次使用:Plistbin命令将XML转换成二进制进行保存。<br>你可以使用Xcode查看plist文件，优势在于他可以用下拉菜单来显示所有可用的键，这些键对应不同类型的值。不过你最好掌握在命令行中处理plist文件的做法，这样将来可以通过SSH与越狱设备进行交互。</p>
<p>可以通过man手册来查看更多关于plist(5)和plutil(1)的信息。如果你正在使用越狱设备，则可以直接使用Erica Sadum的Erica Utilities（可以在Cydia下载安装）中的plutil命令在设备上处理plist文件。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 11适配：contentInsetAdjustmentBehavior解析]]></title>
      <url>/2017/12/13/27/</url>
      <content type="html"><![CDATA[<p>上一篇一篇文章介绍了影响页面布局的几个属性，如今iOS 11出来后变化挺大的，在这里重新梳理下。<br><a id="more"></a><br>可以看到在iOS 11中，UIViewController的automaticallyAdjustsScrollViewInsets属性被弃用了，系统推荐我们使用UIScrollView的contentInsetAdjustmentBehavior属性替代之。关于这个属性，系统提供了四种行为模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIScrollViewContentInsetAdjustmentAutomatic</span><br><span class="line">UIScrollViewContentInsetAdjustmentScrollableAxes</span><br><span class="line">UIScrollViewContentInsetAdjustmentNever</span><br><span class="line">UIScrollViewContentInsetAdjustmentAlways</span><br></pre></td></tr></table></figure></p>
<p>第3、4种看起来比较清晰，要么不调整，要么”一直”调整。但估计不少朋友看到第1、2种会一脸懵逼，包括第4种里“一直”这个词。在这解释之前我们先分析下为什么automaticallyAdjustsScrollViewInsets会被弃用。</p>
<p>在我看来原因可能之前使用automaticallyAdjustsScrollViewInsets的方案太单调粗暴了。当处于 ①(文末末尾)情况时的scrollView，系统会自动修改其contentInset属性，举个例子:如果存在状态栏和导航栏，则contentInset的top值则会被修改为64，内容自动下移64。当底部存在系统UITabBar时，则bottom值修改为49，即下方额外增加49的滚动距离。</p>
<p>我们知道iOS 11后引入了安全区的概念safeAreaInsets。</p>
<img src="/2017/12/13/27/1970468-e93887c3ec1be77e.jpg">
<p>以不带UITabBar的iPhone X为例：NavigationController的rootViewController.view（以下用self代称该rootViewController）,其safeAreaInsets为{88, 0, 34, 0}，在contentInsetAdjustmentBehavior属性出现之前，系统是根据①情况进行的调整。而现在，系统将会根据ScrollView视图大小(包括其类族UITableView等)是否超过了安全区来进行调整，需要注意的有两点：</p>
<ol>
<li><p>这个”调整”不再是直接修改scrollView.contentSize，而是scrollView.adjustedContentInset</p>
</li>
<li><p>调整的值将根据具体超出多少值来确定，但最大值不能超过安全区的相应EdgeInsets方向的值。以self.view的safeAreaInsets为{88, 0, 34, 0}为例。此时添加一个tableView，其高度为self.view.short_height + 25，那么tableView.adjustedContentInset的bottom则为25。但如果超出高度为134，bottom最高也只会是34，这样就会由于表格高度超过屏幕100，而出现”拉不到底部”的情况。</p>
</li>
</ol>
<p>第二点的效果相比以前的automaticallyAdjustsScrollViewInsets方案，可以说智能很多，因为当处于①情况时，哪怕你的scrollView的布局位置根本就没被导航栏挡住，它都会给你调整64。然后你就发现莫名起妙内容就被下移了。</p>
<img src="/2017/12/13/27/1970468-86b43da6709859fe.png">
<p>接下来我们再说回contentInsetAdjustmentBehavior属性的这四个值：</p>
<p>首先是UIScrollViewContentInsetAdjustmentNever，如名所示：就算你的ScrollView超出了safeAreaInsets，系统不会对你的scrollView.adjustedContentInset做任何事情，即不作任何调整；</p>
<p>UIScrollViewContentInsetAdjustmentAlways: 只要超了安全区，就调整相应的超出值，调整的最大值不会超过安全区相应EdgeInsets方向的最大值，如刚刚上述第2点；</p>
<p>UIScrollViewContentInsetAdjustmentScrollableAxes：系统会根据ScrollView的滚动方向来进行判断，假设我只是一个横向滚动的ScrollView，那即便我的布局起点和高度值超过了self.view的安全区，那么系统也不会调整scrollView.adjustedContentInset对应的top与bottom方向值，只可垂直方向滚动同理，直接设置scrollView.scrollEnabled = NO也同理；</p>
<p>UIScrollViewContentInsetAdjustmentAutomatic：系统默认值。文档上是这样说的：</p>
<blockquote>
<p>Similar to .scrollableAxes, but for backward compatibility will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller,</p>
</blockquote>
<p>其实文档已经说的很清楚了，它与UIScrollViewContentInsetAdjustmentScrollableAxes行为相似，但是为了兼容以前①这种情况，即使scrollView是不可滚动，也会根据safeAreaInsets超出范围进行调整。（具体效果可以试着自己上手调试，这里就不贴代码和示意图了）。</p>
<p>关于刚才说的注意点二，我想补充的是，当出现表格过高(比如超出了100)而导致”拉不到底部”的情况时，你可以选择额外设置tableView.contentInset属性，bottom方向设为100，或者选择修改self.additionalSafeAreaInsets的属性。前者影响tableView.adjustedContentInset值，后者影响self.view.safeAreaInsets。你会发现刚好是两数之和，事实上adjustedContentInset的值正是由contentSize加上contentInsetAdjustmentBehavior所调整的值。而self.view.safeAreaInsets会在原来的基础上，加上你的additionalSafeAreaInsets。由于我们很少直接修改contentSize，所以基本上tableView.adjustedContentInset都是系统的调整值。</p>
<p>其实，苹果可能本意是方便开发者，但事实上如果你对这些属性的来龙去脉不太了解清楚的话，确实是挺不方便的。。。因此可能现在很多的人做法都是一开始就设置之前的automaticallyAdjustsScrollViewInsets为NO，设置新的contentInsetAdjustmentBehavior为UIScrollViewContentInsetAdjustmentNever。就我个人看来，如果你需要实现类似系统默认那种表格穿透半透明导航栏或者底部半透明TabBar的效果时，这个属性使用起来就很舒服，直接tableView.frame = self.view.bouds 或者make.edges.equal.to(self.view)就好了。而无需再设置额外的contentSize。如果不需要类似的穿透，那可以选择直接将其禁止。</p>
<p>① scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller<br>PS：并且该scollView是第一个被添加的子视图</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中class func与static func的区别]]></title>
      <url>/2017/12/13/23/</url>
      <content type="html"><![CDATA[<p>在开发过程中遇到了这么一个问题，有些人喜欢用class func来写静态方法，有些人则喜欢用static func来写静态方法。其实从翻译的角度来说，static func叫作静态方法更合适一些。</p>
<a id="more"></a>
<p>这里为了明确两者区别，可以做一个简单的实验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">    class func func1() -&gt; String &#123;</span><br><span class="line">        return &quot;func1&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func func2() -&gt; String &#123;</span><br><span class="line">        return &quot;func2&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class final func func3() -&gt; String &#123;</span><br><span class="line">        return &quot;func3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassB : ClassA &#123;</span><br><span class="line">    override class func func1() -&gt; String &#123;</span><br><span class="line">        return &quot;func1 in ClassB&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ERROR: Cannot override static method</span><br><span class="line">    override static func func2() -&gt; String &#123;</span><br><span class="line">        return &quot;func2 in ClassB&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // ERROR: Class method overrides a &apos;final` class method</span><br><span class="line">    override class func func3() -&gt; String &#123;</span><br><span class="line">        return &quot;func3 in ClassB&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码可以看出，其实在Swift中static func 相当于class final func。禁止这个方法被重写。</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[影响导航控制器中页面布局的几个属性]]></title>
      <url>/2017/12/13/26/</url>
      <content type="html"><![CDATA[<p>关于iOS的适配一直有许许多多的坑，今天来简单说一下最主要的几个影响布局的属性。<br><a id="more"></a></p>
<h3 id="先来介绍几个主要属性"><a href="#先来介绍几个主要属性" class="headerlink" title="先来介绍几个主要属性"></a>先来介绍几个主要属性</h3><blockquote>
<p>UIViewController 的 edgesForExtendedLayout<br>UIViewController 的 extendedLayoutIncludesOpaqueBars<br>UIViewController 的 automaticallyAdjustsScrollViewInsets<br>NavigationBar 的 translucent</p>
</blockquote>
<ol>
<li><p>edgesForExtendedLayout属性的系统默认值为UIRectEdgeAll：意味着当导航控制器的导航栏为半透明效果时，子控制器self.view布局的起始位置将从屏幕边缘左上角开始。</p>
</li>
<li><p>extendedLayoutIncludesOpaqueBars属性系统默认为NO，Opaque代表非透明，not Includes意味着导航栏不是半透明时，即便当前是UIRectEdgeAll，self.view的布局起始位置依旧是从导航栏下方开始。</p>
</li>
<li><p>translucent属性值会决定导航栏是否有半透明效果。translucent为NO，意味着导航栏为非透明，此时如上文所述，即便当前是UIRectEdgeAll，由于extendedLayoutIncludesOpaqueBars为默认NO，self.view的布局起始位置依旧是从导航栏下方开始。</p>
</li>
<li><p>至于automaticallyAdjustsScrollViewInsets属性，系统默认值为YES。意味着当导航控制器的childViewController.view的上层视图为scollView类簇时，则系统会自动为该scrollView的contentInset(内边距属性)的Top值增加额外的64，于是内容就会下移64。</p>
</li>
</ol>
<h3 id="关于translucent属性需要特别注意的是："><a href="#关于translucent属性需要特别注意的是：" class="headerlink" title="关于translucent属性需要特别注意的是："></a>关于translucent属性需要特别注意的是：</h3><blockquote>
<p>根据官方文档所述：translucent会受navigationBar的backgroudImage属性的影响。也就是说当你使用了一张自定义图片作为navigationBar的背景图时，translucent的值将由系统根据该图片是否颜色值透明，来推断translucent是YES还是NO。</p>
</blockquote>
<p>于是坑就来了：对于导航控制器中的各个childViewController，是共用同一个的navigationBar。当你在一个childViewController中自定义了navigationBar的背景图片，或是直接改变了translucent属性，此时再push或pop到另一个childViewController时，更改导航栏的半透明效果可能会影响到页面的布局起始位置，从而发生视图发生跳动，出现“意外”的上下偏移。</p>
<p>举个例子：从一个设置了导航栏不透明的控制器A，pop回到一个原本设置了导航栏透明的控制器B时，B页面发生了下移。</p>
<blockquote>
<p>为避免该情况，应该将控制器B的extendedLayoutIncludesOpaqueBars设置为YES；或是当B页面viewWillAppear:时，再度将导航栏设置为半透明效果。</p>
</blockquote>
<h3 id="关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是"><a href="#关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是" class="headerlink" title="关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是"></a>关于automaticallyAdjustsScrollViewInsets属性需要特别注意的是</h3><blockquote>
<p>以tableView为例，当你使用默认的创建方式，也就是UIRectEdgeAll+导航栏半透明的情况下，首行cell的位置将处于导航栏下方，也就是屏幕坐标系的(0, 64)位置处，此时上滑将会形成穿透效果导航栏的效果。</p>
</blockquote>
<p>补充：当你的设计中出现导航栏穿透效果，自定义非透明的导航栏背景、导航栏完全透明等需求时，记得结合上述几点进行判断处理，避免发生预想之外的界面偏差。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS11 UITableView顶部多出一片空白区域]]></title>
      <url>/2017/12/13/25/</url>
      <content type="html"><![CDATA[<p>苹果向来都是出个bug让开发者填坑，这不弄了个iPhone X的异形屏幕，既要考虑顶部的齐刘海，又要考虑底部的home条。现在不光是iPhone X的屏幕问题，iOS 11的SDK也有好多改变，其中影响最大的莫过于UITableView的改动。</p>
<a id="more"></a>
<p>很多开发者发现了，用iOS 11的SDK运行程序后tableView变得自己都不认识了。</p>
<p>首先是在iOS 11中，tableView关于footer的两个代理方法必须成对出现，不然就会有问题。这里以footer为例，header同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section</span><br><span class="line">-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section</span><br></pre></td></tr></table></figure></p>
<p>这两个方法只要出现一个，另一个就必须写上。不然footer的高度就无法控制了。。</p>
<p>其次，很多人发现自己的tableView下移了64个像素。</p>
<p>在iOS11之前，如果想要scrollView不偏移64p，则需设置automaticallyAdjustsScrollViewInsets=NO，但是这个属性在iOS11直接被遗弃了。。</p>
<p>多出了一个新属性contentInsetAdjustmentBehavior，类型是UIScrollViewContentInsetAdjustmentBehavior。看起来这和iOS11搞的safeArea有关，这个先放一边，看看怎么适配(一种简单方案)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">    tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Fallback on earlier versions</span><br><span class="line">    self.automaticallyAdjustsScrollViewInsets = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看一下这个新的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIScrollViewContentInsetAdjustmentBehavior) &#123;</span><br><span class="line">    UIScrollViewContentInsetAdjustmentAutomatic, // Similar to .scrollableAxes, but will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewContentInset = YES inside a navigation controller, regardless of whether the scroll view is scrollable</span><br><span class="line">    UIScrollViewContentInsetAdjustmentScrollableAxes, // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)</span><br><span class="line">    UIScrollViewContentInsetAdjustmentNever, // contentInset is not adjusted</span><br><span class="line">    UIScrollViewContentInsetAdjustmentAlways, // contentInset is always adjusted by the scroll view&apos;s safeAreaInsets</span><br><span class="line">&#125; API_AVAILABLE(ios(11.0),tvos(11.0));</span><br></pre></td></tr></table></figure></p>
<p>关于这个属性我会在另一篇文章中详细解释一下。</p>
<p>下面是一种大神的解决方案，是从网上找的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define  adjustsScrollViewInsets_NO(scrollView,vc)\</span><br><span class="line">do &#123; \</span><br><span class="line">    _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">    _Pragma(&quot;clang diagnostic ignored \&quot;-Warc-performSelector-leaks\&quot;&quot;) \</span><br><span class="line">    if ([UIScrollView instancesRespondToSelector:NSSelectorFromString(@&quot;setContentInsetAdjustmentBehavior:&quot;)]) &#123;\</span><br><span class="line">        [scrollView   performSelector:NSSelectorFromString(@&quot;setContentInsetAdjustmentBehavior:&quot;) withObject:@(2)];\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        vc.automaticallyAdjustsScrollViewInsets = NO;\</span><br><span class="line">    &#125;\</span><br><span class="line">    _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure></p>
<p>这种方法是利用了宏定义。但是在iOS 11的SDK中，我发现有的时候宏定义或者全局变量的值并不是我所期望的值，使用NSLog打印的值跟通过计算后得到的值匹配不上。我不确定这是Xcode9的bug还是其他什么原因，特别是计算frame的时候，明明单独打印这几个宏定义的值都对，但是把这几个宏定义进行计算，得到的结果却是错误的。。如果有人遇到了同样的问题，麻烦私信我一下。。一起探讨探讨。</p>
<p>最后希望所有的产品经理都紧跟苹果步伐。抛弃旧的系统。。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Win7x64+VS2015Pro+Matlab2016b+OpenCV3.2配置运行TLD]]></title>
      <url>/2017/12/06/21/</url>
      <content type="html"><![CDATA[<p>TLD即Tracking Learning Detection，Zdenek Kalal大神在其<a href="http://info.ee.surrey.ac.uk/Personal/Z.Kalal/tld.html" target="_blank" rel="noopener">主页上给出的代码</a>，是一种实时更新学习库的神级跟踪算法。ZK大神成功的利用这个算法开了一家公司，并且现在已经更新到2.2版本了，放到平板、电脑、工作站中都可以完美运行，已经做到了商业化。虽然开源代码是2011年写的，但是放到现在来说仍有重要的学习意义。</p>
<a id="more"></a>
<p>先说一下，我电脑的程序配置:WIN7x64+VS2015pro+MATLAB2016b+OpenCV3.2，一开始，这个程序在我电脑上始终没有跑起来，我通过在网上找到各种资料进行拼凑，却仍然不能正常运行，以至于一度想要将软件配置成几年前的版本（因为网上有前辈用WIN7+VS2005+MATLAB2011a+OpenCV2.2运行起来了，我的部分资料也是借鉴他的）。</p>
<p>鉴于所有的配置都是几年前的老套路，而OPENCV也已经更新到3.2（今天刚看了下cv的官网，8月初更新到了3.3。。。。。。）。我决定自己总结一篇最新的配置方法。</p>
<p>跑TLD程序，首先应该运行compile.m程序，然后再运行run_TLD.m，在任何机器上，首先得保证matlab的mex命令设置正确，其可通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mex –setup</span><br></pre></td></tr></table></figure></p>
<p>配置好所用VS的编译环境，相关教程不少，之前因为我已经配置过了，此处就省略此步骤。之后打开compile.m<br>源代码中有如下两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include = &apos; -Ic:\OpenCV2.2\include\opencv\ -Ic:\OpenCV2.2\include\&apos;;</span><br><span class="line">libpath = &apos;c:\OpenCV2.2\lib\&apos;;</span><br></pre></td></tr></table></figure></p>
<p>需要改为自己的opencv路径，我的电脑上opencv路径为：<br><img src="/2017/12/06/21/20170829113954171.png"></p>
<p>当然这些只是针对windows pc改的，若换成其它系统环境，则在相应的地方更改。<br>注意，此处有一个问题：我有段时间一直编译不通过其实就是因为lib后面没加’\’，网上的大神都没加。。。<br><img src="/2017/12/06/21/20170829113839057.png"><br>少掉这个“\”会出现如下情况：<br><img src="/2017/12/06/21/20170829114108233.jpeg"></p>
<p><a href="https://github.com/zk00006/OpenTLD/wiki/Installation" target="_blank" rel="noopener">根据作者的说法</a> ：若用VS2010会有不同：<br>You will need some extension toolboxes for Matlab, see below.</p>
<p>1) Install OpenCV2.2: compile OpenCV, set system PATH variable to link to OpenCV DLLs</p>
<p>2) Setup mex compiler in Matlab: run: mex -setup, select Visual Studio 2010 compiler from the list</p>
<p>3) Compilation of mex files: check paths in ‘compile.m’ file, run ‘compile.m’</p>
<p>3.1) If you are using Matlab 2011a, in TLD source, comment out the following lines in lk.cpp, fern.cpp, and bb_overlap.cpp (Otherwise, you will get an error about int being undefined which is a no-no in 2010):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _CHAR16_T</span><br><span class="line">#define CHAR16_T</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>4) run ‘run_TLD.m’, TLD should track a motorbike<br>即如红色部分所示，你需要把<br>lk.cpp, fern.cpp, and bb_overlap.cpp 这几个文件中的这几行代码注释掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _CHAR16_T</span><br><span class="line">#define CHAR16_T</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>但是我在VS2015pro上没有注释掉这几行。结果并没有什么影响，最后还是可以运行的。</p>
<p>按照网上的步骤进行修改后，我又遇到了一个比较恶心的问题，在运行compile.m时，提示我说：<br><img src="/2017/12/06/21/20170829114329806.png"></p>
<p>what??min和max不是在Cpp中有定义的吗？之后看网上的前辈说将#include <stdafx.h>加入头文件可以解决此问题，于是加入后出现：<br><img src="/2017/12/06/21/20170829114414527.png"></stdafx.h></p>
<p>好吧，彻底被打败了。（我一直在想为什么matlab调用的是VS进行编译竟然还找不到VS的头文件库。有知道的大神告诉我一下），既然调用头文件不能用的话，那就自己写一个定义吧：<br><img src="/2017/12/06/21/20170829114522568.jpeg"><br>之后再运行compile.m，无报错.</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Xcode8,Xcode9 查看模拟器沙盒目录的方法]]></title>
      <url>/2017/12/05/12/</url>
      <content type="html"><![CDATA[<p>自从升级到Xcode8之后，所有的插件都被禁用了，那么应该如何进入模拟器的沙盒目录呢？</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray * paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSLog(@&quot;%@&quot;, paths[0]);</span><br></pre></td></tr></table></figure>
<p>打开Finder，点前往<br>把打印出来的path复制到输入框中按回车即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo中的Yelee主题，首页不显示文章摘要]]></title>
      <url>/2017/12/04/2/</url>
      <content type="html"><![CDATA[<p>最近在用Hexo自己搭建博客，使用了文档比较全的Yelee主题，但是在使用过程中发现了一个大问题，在所有文章列表中有文章，但是首页却不显示文章摘要。</p>
<a id="more"></a>
<p>我找了一下，发现是themes/yelee/layout/_partial/head.ejs中的这段代码的search: &lt;%= theme.search.on %&gt;定义有问题。</p>
<p>具体代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var yiliaConfig = &#123;</span><br><span class="line">    fancybox: &lt;%=theme.fancybox%&gt;,</span><br><span class="line">    animate: &lt;%=theme.animate%&gt;,</span><br><span class="line">    isHome: &lt;%=is_home()%&gt;,</span><br><span class="line">    isPost: &lt;%=is_post()%&gt;,</span><br><span class="line">    isArchive: &lt;%=is_archive()%&gt;,</span><br><span class="line">    isTag: &lt;%=is_tag()%&gt;,</span><br><span class="line">    isCategory: &lt;%=is_category()%&gt;,</span><br><span class="line">    fancybox_js: <span class="string">"&lt;%- theme.CDN.fancybox_js %&gt;"</span>,</span><br><span class="line">    scrollreveal: <span class="string">"&lt;%- theme.CDN.scrollreveal %&gt;"</span>,</span><br><span class="line">    search: &lt;%= theme.search.on %&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看这里最后一个search，里面用的是on，而在yelee主题的_config.xml里默认设置是search:onload:false，这里写的是onload而不是on，导致Uncaught ReferenceError: yiliaConfig is not defined。</p>
<p>解决方法是把两边的变量名改成一样就可以了，比如yelee主题的_config.xml里面的search:onload false改成search:on false，这样就正常运行了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Windows电脑上给Python配置OpenCV]]></title>
      <url>/2017/12/01/22/</url>
      <content type="html"><![CDATA[<p>许多开发者想在PYTHON中配置OPENCV，但又不知道怎么做，最近一直在搞这一方面，也是混沌了好几天，最后终于有了些眉目，和大家分享一下</p>
<a id="more"></a>
<h2 id="安装PYTHON"><a href="#安装PYTHON" class="headerlink" title="安装PYTHON"></a>安装PYTHON</h2><p>我用的是python3.5版本，官网就能下，跟着教程走，配置好PATH包就能在C字命令符中调用了，调用结果如下：<br><img src="/2017/12/01/22/20170310104620566.jpeg"><br>按回车后：<br><img src="/2017/12/01/22/20170310104638243.jpeg"></p>
<h2 id="安装opencv之前要干的工作"><a href="#安装opencv之前要干的工作" class="headerlink" title="安装opencv之前要干的工作"></a>安装opencv之前要干的工作</h2><p>第二步开始，均是在C字命令符下操作！！！！！均是在C字命令符下操作！！！！！均是在C字命令符下操作！！！！！重要的事情说三遍</p>
<p>安装opencv之前要干的工作：<br>C字命令符中输入：<br>python -m pip install -U pip<br>按回车，自动安装pip包<br>之后下载numpy和opencv的python3.5版本：</p>
<p>这里给出几个网站：<br>Numpy：   <a href="https://pypi.python.org/pypi/numpy" target="_blank" rel="noopener">https://pypi.python.org/pypi/numpy</a></p>
<img src="/2017/12/01/22/20170310104653489.jpeg">
<p>看这些很乱看不懂对吧？其实很简单：</p>
<p>最长的都是土豪专用OSX版本。</p>
<p>处于中间不长不短的是Linux系统的。</p>
<p>最短的都是windows32位的版本（这的位数指的是python的！！！！不是系统的！！！32位系统也是可以安装64位python的！！！）。嗯，剩下的amd64就是windows用64位版本的。</p>
<p>之后cp27,34,35,36指的就是PYTHON的2.7  3.4  3.5  3.6版本，下载对应版本的就可以了。</p>
<p>我下的是numpy-1.12.1rc1-cp35-none-win_amd64.whl (md5, pgp)</p>
<p>Opencv：<a href="http://www.lfd.uci.edu/%7Egohlke/pythonlibs/#opencv" target="_blank" rel="noopener">http://www.lfd.uci.edu/%7Egohlke/pythonlibs/#opencv</a><br>进入之后会发现乱七八糟一大堆。。。</p>
<img src="/2017/12/01/22/20170310104706145.jpeg">
<p>看到红圈了吗。。。那就是opencv，点一下就到了下载opencv的地方了。。如下图：</p>
<img src="/2017/12/01/22/20170310104724025.jpeg">
<p>这里要下哪个就不用多说了，解释见上，命名方式都一样。<br>我用的是：opencv_python‑3.2.0+contrib‑cp35‑cp35m‑win_amd64.whl<br>至于多了个contrib，是多了些高级功能的包包，具体作用可以百度，问题不大。</p>
<h2 id="Opencv安装包的问题"><a href="#Opencv安装包的问题" class="headerlink" title="Opencv安装包的问题"></a>Opencv安装包的问题</h2><p>下载完后，你会得到两个.whl包包：然后放置在C字命令符开始的目录下（这样就不用你自己再填写路径了！！！！）：<br>注意！！！<br>对于opencv安装包<br>改之前：opencv_python‑3.2.0+contrib‑cp35‑cp35m‑win_amd64.whl<br>一定要把cp35m改成none！！<br>改之后：opencv_python‑3.2.0+contrib‑cp35‑none‑win_amd64.whl</p>
<p>如果不改的话不然会出现：<br>opencv_python-3.2.0+contrib-cp35-cp35m-win_amd64.whl is not a supported wheel on this platform.</p>
<img src="/2017/12/01/22/20170310104745068.jpeg">
<h2 id="安装Opencv"><a href="#安装Opencv" class="headerlink" title="安装Opencv"></a>安装Opencv</h2><p>安装，C字命令符中输入<br>pip3 install numpy-1.12.1rc1-cp35-none-win_amd64.whl<br>安装numpy<br>输入pip3 install opencv_python‑3.2.0+contrib‑cp35‑none‑win_amd64.whl</p>
<img src="/2017/12/01/22/20170310104756600.jpeg">
<p>忽略画叉的那些，下边这个就是安装成功后的样子。</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用~"></a>开始使用~</h2><p>打开python3.5.2 shell，不是像c字命令符的那个！！！！！<br>输入improt cv2回车</p>
<img src="/2017/12/01/22/20170310104808741.jpeg">
<p>无报错，安装成功</p>
<p>最后吐槽一下这些网站。。写个漂亮点的CSS就这么难么。</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 设置Launchpad 的列数和行数]]></title>
      <url>/2017/11/13/3/</url>
      <content type="html"><![CDATA[<p>这两天在搞博客的事情，发现Mac的Launchpad里面一页显示的东西太少，很不方便，于是就搜集了一下如何让她显示更多图标的方法。</p>
<a id="more"></a>
<p>打开终端。</p>
<ol>
<li><p>设置 Launchpad 的列数，对应于每一行 App 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-columns -int 列数</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 Launchpad 的行数，对应于每一列 App 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows -int 行数</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置 Launchpad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置 Dock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[加密和签名的区别]]></title>
      <url>/2017/11/08/4/</url>
      <content type="html"><![CDATA[<p>最近在研究RSA，对其中的签名和加密的概念不是很理解，从网上搜了搜，在这里总结一下。</p>
<a id="more"></a>
<p>举个例子，就拿A给B发送经过签名加密信息来说：<br>1、A对信息签名的作用是确认这个信息是A发出的，不是别人发出的；<br>2、加密是对内容进行机密性保护，主要是保证信息内容不会被其他人获取，只有B可以获取。也就是保证整个过程的端到端的唯一确定性，这个信息是A发出的（不是别人），且是发给B的，只有B才被获得具体内容（别人就算截获信息也不能获得具体内容）。</p>
<p>这只是大概说了作用，具体说来，涉及到密钥相关的东西。密钥有公钥和私钥之分。</p>
<p>那么这里一共有两组四个密钥：<br>A的公钥（PUB_A），A的私钥（PRI_A）；B的公钥（PUB_B），B的私钥（PRI_B）。</p>
<p>公钥一般用来加密，私钥用来签名。</p>
<p>通常公钥是公开出去的，但是私钥只能自己私密持有。<br>公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；同样用某个私钥加密的内容只能用对应的公钥才能解密。</p>
<p>这时A向B发送信息的整个签名和加密的过程如下：<br>1、A先用自己的私钥（PRI_A）对信息（一般是信息的摘要）进行签名。<br>2、A接着使用B的公钥（PUB_B）对信息内容和签名信息进行加密。</p>
<p>这样当B接收到A的信息后，获取信息内容的步骤如下：<br>1、B用自己的私钥（PRI_B）解密A用B的公钥（PUB_B）加密的内容；<br>2、得到解密后的明文后用A的公钥（PUB_A）解签A用A自己的私钥（PRI_A）的签名。</p>
<p>从而整个过程就保证了开始说的端到端的唯一确认。<br>A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的。<br>A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取。</p>
<p>这个过程可以这么个故事来概括:<br>B的银行卡落到A的家里了，A要给B邮寄银行卡，提前和B说了我要给你寄银行卡(B拿到A的公钥)，<br>A在寄银行卡的时候要求快递员在B收到东西时说出是谁寄的(A用自己的私钥进行签名)，只有说对了才给B(B用A的公钥验证签名)。</p>
<p>这张银行卡对于快递员来说是加密的(快递员既不知道银行卡是谁的，也不知道银行卡密码)，但是对于A来说，A知道银行卡是谁的(相当于B的公钥)，而对于B来说，B有银行卡的密码(B的私钥)。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[no rule to process file 'xxx.h' of type sourcecode.c.h for architecture armv7]]></title>
      <url>/2017/11/02/29/</url>
      <content type="html"><![CDATA[<p>Xcode编译提示：[WARN]warning: no rule to process file ‘xxx.h’ of type sourcecode.c.h for architecture armv7<br><a id="more"></a><br>iOS开发中，Xcode编译出现如下警告提示： [WARN]warning: no rule to process file xxx.h’ of type sourcecode.c.h for architecture armv7</p>
<p>这是因为检查到有.h文件在编译列表中了。<br>所以只要在列表中去掉就可以。<br>点击你的xcode项目文件，然后点击『Build Phases』，确保在『Compile Sources』中没有.h文件。</p>
]]></content>
      
        
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度探索TLD的C++源码]]></title>
      <url>/2017/11/01/32/</url>
      <content type="html"><![CDATA[<p>首先提一点，我用的环境是VS2015+OpenCV3.2，在不同的环境下配制方法有出入，请对号入座。<br><a id="more"></a></p>
<h3 id="网上的TLD有两个版本，一个是Zdenek-Kalal自己使用matlab-vs混合编程实现的，另外一个是-arthurv利用c-和opencv实现的。"><a href="#网上的TLD有两个版本，一个是Zdenek-Kalal自己使用matlab-vs混合编程实现的，另外一个是-arthurv利用c-和opencv实现的。" class="headerlink" title="网上的TLD有两个版本，一个是Zdenek Kalal自己使用matlab+vs混合编程实现的，另外一个是 arthurv利用c++和opencv实现的。"></a>网上的TLD有两个版本，一个是Zdenek Kalal自己使用matlab+vs混合编程实现的，另外一个是 arthurv利用c++和opencv实现的。</h3><p>1.1、我利用的是arthurv版本的Tracking-Learning-Detection<br>连接：<a href="https://github.com/alantrrs/OpenTLD" target="_blank" rel="noopener">https://github.com/alantrrs/OpenTLD</a></p>
<p>1.2、下载得到的C++代码如下所示<br>其中：<br>datasets是一些视频数据；<br>doc是程序的流程图进行说明；<br>include是头文件；<br>src是源文件；<br>parameters.yml是参数文件；<br>readme是程序运行说明。</p>
<h3 id="我们只要用到datasets、include、src、parameters-yml"><a href="#我们只要用到datasets、include、src、parameters-yml" class="headerlink" title="我们只要用到datasets、include、src、parameters.yml;"></a>我们只要用到datasets、include、src、parameters.yml;</h3><p>下面讲述如何在VS2015下创建工程；</p>
<p>2.1、创建一个空的solution(没有预编译的控制台程序)</p>
<p>2.2、首先将include中的文件拷贝放到src的文件夹中；然后将src、datasets、parameters.yml放到solution的工程目录下，如下所示：<br><img src="/2017/11/01/32/20171101102925801.jpeg"></p>
<p>2.3、编译项目，此时会冒出错误，下面为解决方法：<br>a．首先将头文件包含错误的全部由include<tld.h> 改成 include “TLD.h”;其他的头文件包含以此类推；解释一下：&lt;&gt;的引用是在整个文件目录，包括系统环境变量库里找，而“”是在当前文件目录里找。</tld.h></p>
<p>b．关于在TLD.h中包含头文件#include <opencv2 legacy="" legacy.hpp="">的问题；由于原作者是在opencv2.4的版本下进行的编译，由于opencv3的各种版本相对于opencv2的版本已经改变了很多内容，openTLD跟踪算法所依赖的一些函数在opencv3中已经消失了，最重要的一点就是到了Opencv3.2中已经不包括legacy.hpp库，所以我们需要添加PatchGenerator.h和PatchGenerator.cpp两个文件，并在对应的地方include头文件（对应的删掉legacy.hpp），才能做到不缺失文件。<br>两个文件参考地址：<a href="http://blog.csdn.net/j10527/article/details/51305087" target="_blank" rel="noopener">http://blog.csdn.net/j10527/article/details/51305087</a></opencv2></p>
<p>c．LKTracker.cpp中：需要添加如下几行，以防止调用不到定义函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/11/01/32/20171101103053722.jpeg">
<p>d．在TLD.h中，由于C++中的数组不能为变量，所以需要做如下修改：<br>将const int c = dbb.size();改为：<br>const int c = 100; 即定义为常数<br><img src="/2017/11/01/32/20171101103219250.jpeg"></p>
<p>e.对应的，TLD::clusterBB函数中，vs不支持动态数组分配。其中的动态数组需要改成指针和动态分配内存，并且需要在结尾处释放内存。<br><img src="/2017/11/01/32/20171101103256523.jpeg"><br><img src="/2017/11/01/32/20171101103314568.jpeg"></p>
<p>f．round、ceil和floor可能会出现错误，原因是round和ceil内部传入的参数必须是double或者float型，所以将这三个函数里面的数据改为float型，具体做法就是里面的整数后面加上小数点，比如2，就改为2.0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int stepx = ceil(double((bb.width - 2.0 * margin_h)/max_pts));</span><br><span class="line">int stepy = ceil(double((bb.height - 2.0 * margin_v)/max_pts));</span><br></pre></td></tr></table></figure></p>
<img src="/2017/11/01/32/20171101103353732.jpeg">
<p>g.打开run_tld.cpp 将其中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (strcmp(argv[i],&quot;-tl&quot;)==0)&#123;</span><br><span class="line">    tl = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (strcmp(argv[i],&quot;-no_tl&quot;)==0)&#123;</span><br><span class="line">    tl = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/11/01/32/20171101103537148.jpeg">
<p>对于下图这个修改，我是试过的，但是会出现如下问题：所以tl=false没有变，具体是为什么会出问题我还没有查明。<br><img src="/2017/11/01/32/20171101103600584.jpeg"><br><img src="/2017/11/01/32/20171101103624414.png"><br><img src="/2017/11/01/32/20171101103653092.jpeg"></p>
<p>h．最后，由于这个项目是里面是先产生一个可执行文件在cmd下来执行，并且需要采用cmd命令预先调用parameters.yml中的初始化参数。这样不方便我们调试；因此我们要修改程序一开始的参数解析函数：<br><img src="/2017/11/01/32/20171101103731426.jpeg"></p>
<p>2.4 release完成后，在生成的文件夹中直接打开EXE文件，完美运行（仅对摄像头，测试视频未调用）<br><img src="/2017/11/01/32/20171101103830769.jpeg"></p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift4.0 strtoul、strtod、strtof、strtol等字符串函数的改变]]></title>
      <url>/2017/10/26/24/</url>
      <content type="html"><![CDATA[<p>在新的iOS 11的SDK中，这几个函数参数类型发生了改变</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public func strtod(_: UnsafePointer&lt;Int8&gt;!, _: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!) -&gt; Double</span><br><span class="line"></span><br><span class="line">public func strtof(_: UnsafePointer&lt;Int8&gt;!, _: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!) -&gt; Float</span><br><span class="line"></span><br><span class="line">public func strtol(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; Int</span><br><span class="line"></span><br><span class="line">public func strtoll(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; Int64</span><br><span class="line"></span><br><span class="line">/* !__DARWIN_NO_LONG_LONG */</span><br><span class="line">public func strtoul(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; UInt</span><br><span class="line"></span><br><span class="line">public func strtoull(_ __str: UnsafePointer&lt;Int8&gt;!, _ __endptr: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;!, _ __base: Int32) -&gt; UInt64</span><br></pre></td></tr></table></figure>
<p>从原来可以直接传的char*变成了一个UnsafePointer<int8>。那么我们用到函数的地方也要改变一下，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s = hex[hex.characters.index(hex.startIndex, offsetBy: start)..&lt;hex.characters.index(hex.startIndex, offsetBy: end)]</span><br><span class="line">return CGFloat(s.withCString&#123;strtoul($0, nil, 16)&#125;)</span><br></pre></td></tr></table></figure></int8></p>
<p>这里的s是一个String类型，他有一个withCString方法。利用这个方法可以将字符串中的字符转换成UnsafePointer<int8>类型。</int8></p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决NSTimer在UITableView滑动中暂停问题]]></title>
      <url>/2017/09/04/30/</url>
      <content type="html"><![CDATA[<p>最近在研究动画特效。发现将NSTimer动画添加到tableVIew上的时候会遇见动画暂停的问题，其实是动画的计时器停止了，经过研究找到了解决方法， 和大家分享一下。<br><a id="more"></a><br>当你使用下面这个方法创建NSTimer的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class func scheduledTimer(timeInterval ti: TimeInterval, target aTarget: Any, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) -&gt; Timer</span><br></pre></td></tr></table></figure></p>
<p>在tableview滑动时timer就是显示暂停，原因是timer的这个简便构造方法把timer加入了NSRunLoopDefaultMode上，而tableview在滑动时只会处理UITrackingRunLoopMode，也就是说当前的RunLoop并没有功夫处理timer事件。</p>
<p>解决的方法是将timer绑定到NSRunLoopCommonModes上，通过以下方法构造timer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init(timeInterval ti: TimeInterval, target aTarget: Any, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool)</span><br></pre></td></tr></table></figure></p>
<p>这样timer在tableview滑动中就不会暂停了。</p>
<p>当然这样做也不是100%能解决问题，有时timer计时不准确。具体的解决方法可以参考这个：<br><a href="http://blog.csdn.net/martin_liang/article/details/40783057" target="_blank" rel="noopener">http://blog.csdn.net/martin_liang/article/details/40783057</a><br>但是像我这样做动画、对时间精确度要求不高的，倒是可以用这个方法解决问题。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MATLAB2016b 中运行color_tracker出错]]></title>
      <url>/2017/08/28/33/</url>
      <content type="html"><![CDATA[<p>最近在研究视觉追踪算法，看到了一篇Adaptive Color Attributes for Real-Time Visual Tracking，俗称CN的视觉追踪算法，从官网下载程序之后，在公司的电脑上（MATLAB2014a）完美运行，但是在我的电脑MATLAB2016b上却运行出错。</p>
<a id="more"></a>
<p>具体错误如下：<br><img src="/2017/08/28/33/20170828151236654.jpeg"></p>
<p>报错提示我Number值必须是双精度标量或空矩阵！！！<br>于是我在网上寻找相关的资料，发现并没有与之相关的错误出现（根本就没有figure中number的用法！！！），但是在寻找中我发现了某个网站贴出了详细的figure应用格式表：<br>在仔细查看后发现了如下一个应用：<br><img src="/2017/08/28/33/20170828151435869.jpeg"></p>
<p>注意这个缺省值，不就是figure所需要的“空矩阵”吗？，于是我将对应出错的那一段改成了如下形式：把number用userdata进行了替换：<br><img src="/2017/08/28/33/20170828151637804.jpeg"><br>再次运行，完美解决。<br><img src="/2017/08/28/33/20170828151654822.jpeg"></p>
<p>ps：虽然自己找到了可以解决运行的方法，但是可能会有点“野狐禅”的感觉，因为自己对matlab的应用还不够熟练，以后还是要多多学习，不过还是邓爷爷说得好，不管黑猫白猫，能抓到老鼠的就是好猫，所以只要能解决问题就行了~</p>
]]></content>
      
        
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(五) ---- 挑战AppStore审核]]></title>
      <url>/2017/05/02/20/</url>
      <content type="html"><![CDATA[<p>当开发一个应用或评估其面对的威胁时，需要将用户设备上的其他应用考虑进来。设备上任何恶意的第三方应用程序都能通过IPC机制与其他应用交互，也能窃取用户的私人信息。AppStore的应用程序审查是对抗这些恶意程序最有力的武器。</p>
<a id="more"></a>
<p>苹果公司没有公开披露他们的审查技术，而该技术主要用来检查应用能否满足AppStore的上架要求。可以确定的是，苹果使用了二进制分析和动态测试技术。这一过程可以将绝大部分带有明显恶意的应用拒之门外，也阻止了一些苹果不喜欢的应用上架(比如多种通信应用，色情或者重口味的应用)。</p>
<p>尽管苹果公司付出了很大努力来确保用户可以用到安全和高质量的应用，但事实证明，一个中等水平的攻击者完全有能力伪装一个动态代码更新应用，让他通过苹果商店的审查。主要有以下几个方式。</p>
<h2 id="WebKit桥接："><a href="#WebKit桥接：" class="headerlink" title="WebKit桥接："></a>WebKit桥接：</h2><p>基于WebKit桥接，可以通过JavaScript使用一些iOS的原生API，比如获取用户位置和使用媒体服务。PhoneGap就是一个典型的框架，以及最近很火的JSPatch。这种方式可以提供能多有用的功能，但使用它们也意味着应用程序的许多逻辑要写成JavaScript，因此不需要打包到应用中。举个例子，一个开发者可以使用JavaScript实现一个常规的打开文件功能，然后在应用审核期间不做任何的恶意操作。一旦审核通过，开发者可以修改设备的JavaScript，从而读取设备上那些本应该是禁区的数据。当然，现在这种热更新已经被苹果明令禁止了。所有使用了热更新框架的开发者都收到了苹果发的警告邮件，限定以后的版本不需使用热更新，不然可能会导致应用程序下架。但是对于Web应用来说，却没有什么明确的限制。还有一些使用了React Native框架的应用程序也没有收到警告，当然，这也不意味着以后苹果不会封杀它，毕竟他的创造者Facebook也只是在一些小应用上使用了这个框架。</p>
<h2 id="动态修复："><a href="#动态修复：" class="headerlink" title="动态修复："></a>动态修复：</h2><p>通常来说，如果一段原生代码没有经过苹果发布的密钥签名认证，应用程序则无法运行它。如果苹果的签名验证逻辑中存在bug或漏洞，那么可能就会允许下载和执行原生代码。iOS有一个特性，前面的文章提到过，可以让程序分配一段没有NX保护的内存区块，该区块可读可写，甚至可以执行，里面运行的代码也不需要经过签名验证。这一机制被苹果用在了Safari的JIT编辑器上，以便实现一些功能，但是这就给了攻击者可趁之机。毕竟有代码的地方就可能出现漏洞，这样第三方应用程序就可以执行相同的把戏。最著名的例子就是Charlie Miller的破解程序，他破解了这个特性。这就意味着原生代码不需要签名认证就可以下载并执行。Miller向AppStore提交了一个股票代码查询应用InstaStock来演示这一过程。在应用审查期间，该应用安分守己，不进行任何恶意或者异常操作。但是一旦通过审核，Miller可以远程遥控该应用程序下载新的，未经签名的代码并执行，整个过程毫无阻碍。当然，现在这个漏洞已经被补上了，但是他却为我们如何骗过审核提供了思路。</p>
<h2 id="故意植入不安全代码："><a href="#故意植入不安全代码：" class="headerlink" title="故意植入不安全代码："></a>故意植入不安全代码：</h2><p>这个绕过AppStore审查的方法很有趣，它会让你的应用变得更加脆弱，很容易受到远程攻击。乔治亚理工学院曾开发过一款用来概念演示的应用Jekyll，他主要用来演示应用内核的缓冲区溢出。恶意代码被打包在应用程序自身之中以便可以顺利获得签名，同样在审查时不进行任何恶意操作，不去调用这些代码。一旦获准上架，开发者能够利用缓冲区溢出的漏洞改变应用程序的控制流，使其导向隐藏的恶意代码。这些代码能够使用苹果的私有框架，进而操控设备的蓝牙、短信甚至其他模块。</p>
<h2 id="内嵌解释器："><a href="#内嵌解释器：" class="headerlink" title="内嵌解释器："></a>内嵌解释器：</h2><p>过去几年，苹果在这方面的政策已经发生了改变，有许多产品(主要是游戏)会使用一个内嵌的Lua解释器来执行大部分的内在逻辑。当然了，过了这么多年，以内嵌解释器为媒介的恶意行为还没有见诸报端，毕竟相对于JavaScript直接调用原生代码来说，Lua解释器对于系统的原声API的操控还是十分受限的，你只能在一个安全的API范围内进行操作。但是，恶意应用可以通过一个类似的解释器来动态下载代码，并在内存中执行。当然，在AppStore的审核中这些恶意代码还是会隐藏自己。通过此方法我们能增加一个新的功能，行为不端的开发者也能较为便利的添加一个恶意功能。</p>
<p>其实AppStore的审核只能清除那些简单的恶意程序，但是恶意程序的确可以从审查人员的眼皮子底下溜走。时刻记住这一点，并在你的应用程序中用代码做好防御，不能假定操作系统中的其他程序都是善意的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(四) ---- 防御代码漏洞和越狱检测]]></title>
      <url>/2017/05/01/19/</url>
      <content type="html"><![CDATA[<p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化(ASLR)和XN bit(eXecute Never的缩写，标记该段内存区域不包含可执行代码)。<br><a id="more"></a></p>
<h2 id="防御代码漏洞："><a href="#防御代码漏洞：" class="headerlink" title="防御代码漏洞："></a>防御代码漏洞：</h2><p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化(ASLR)和XN bit(eXecute Never的缩写，标记该段内存区域不包含可执行代码)。每次执行程序时，ASLR都会随机分配内存、数据、堆和栈的内存位置。共享库需要在多个进程中使用，因此共享库的内存地址只在每次系统重启时随机设置，而不是每次执行程序时。函数和哭的内存地址很难预测，这就预防了缓冲区溢出攻击(return-to-libc)，这种攻击依赖于基本库函数的已知地址。</p>
<p>XN bit一般对于非ARM平台的NX(No-eXecute) bit，允许操作系统将某段内存标记为不可执行，这是由CPU来控制的，学过计算机组成原理的同学都知道，每个CPU指令都有专门的地址存放。在iOS中，这个机制默认应用在程序的堆和栈上。这就意味着，哪怕攻击者可以将恶意代码注入程序的堆和栈，他们也无法重定向应用程序来执行攻击代码。</p>
<p>每个程序都有一段既能写又能执行的内存，前提是他必须经过苹果的官方签名授权系统的签名。Safari中的JavaScript即时(JIT)编译器会用到这段内存。你平时在应用程序中经常使用的WebView并不具备访问相同功能的权利，这样就可以避免代码执行攻击。苹果一直禁止第三方的JIT，好处是更安全，而坏处也很明显，就是iOS平台上的Chrome等其他浏览器无法做到像Safari那样好用，因为他们只能使用WebView。</p>
<h2 id="越狱检测："><a href="#越狱检测：" class="headerlink" title="越狱检测："></a>越狱检测：</h2><p>越狱的本质就是通过一系列步骤来禁用掉苹果的签名机制，从而允许设备运行未经苹果官方审核的应用。越狱还允许你使用那一些便利的开发和测试工具，当然这些工具永远不会通过AppStore的审核。越狱的用户有能力做正常情况下其他iOS用户做不到的事。越狱还有一个至关重要的能力，就是黑箱测试应用程序。</p>
<p>和大多数人想的不一样，越狱不一定要禁用掉iOS的沙盒机制，他只是允许你在沙盒外安装应用程序。安装在移动用户主目录下的应用程序(即从AppStore下载的)仍然受到沙盒的限制。第三方的iOS应用程序需要安装在越狱设备中权限更高的/Applications目录下，与苹果股票应用安装在一起(就是那些你删不掉的系统应用).</p>
<p>越狱检测很早就有，不过没啥用。他的目的是检测设备是否存在不受信任、未经签名的第三方应用程序，从而判断设备是否处在高风险环境中。公平地说，第三方程序库中不乏恶意软件和行为不端的应用程序(像XX万能钥匙。。大家应该很清楚为什么能直接连上别人家的网)，但总体来说，越狱检测不值得你浪费时间去做，因为他无法阻止一个坚定地攻击者。</p>
<p>有一段时间苹果官方推出过越狱检测的API，但很快就在后续的iOS版本中删掉了。具体原因众说纷纭，但是即使没有此API，开发者也找到了一些越狱检测的方法，大家知道就行了，没必要在这里费太多精力。</p>
<p>1.创建一个新进程，例如调用fork()、vfork()、popen()等方法。这是明显会被沙盒机制所禁止的事情。当然，大部分越狱系统上沙河依然是有效的，所以这种检测毫无意义。无论你设备是否越狱，总是可以从AppStore下载应用的。</p>
<p>2.读取沙盒外部的文件，开发者通常想要尝试访问一些二进制代码，这些二进制代码通常对应于ssh、bash，还有一些位于Cydia.app目录和Cydia经常使用的apt仓库等位置。但是这些检测很容易被绕过，并且Xcon6之类的工具也能帮助用户绕过这些自动检查。</p>
<p>3.不要使用太直白的方法名，比如isJailbroken，否则攻击者可以轻易定位并禁掉越狱检测。根据渗透测试同事多年的工作经验来看，像那种不改默认密码或者密码一猜就中的服务器数据库，简直是弱智写的。。还有这些很容易知道是做什么用函数。</p>
<p>还有些更复杂的技术，比如苹果的iBooks应用会尝试运行随着应用打包的未签名代码，而精明的开发者同样会尝试使用_dyld_image_count()和_dyld_get_image_name()来检查载入动态库(dynamiclibrartes, dylibs)的数量和他们的名字，并使用_dyld_get_image_header()来检查他们在内存中的位置。想要绕过这些检测通常需要给应用程序打一个二进制补丁。</p>
<p>想必读者都注意到了，我不是很喜欢搞越狱检测。就像二进制混淆技术和DRM一样，越狱检测被攻击者绕过时只会显得你更加愚蠢。毕竟对于攻击者来说，一些粗略的越狱检测只能拖慢自己前进的脚步几个小时而已。你要知道，对手的爱好就是破解程序，他们通常有大把的时间用来暴力破解，几个小时的时间对于他们而言并没有什么实际意义。我曾经看别人开发过一个二进制混淆程序，然后找渗透测试的同事帮忙测试，仅仅一个工作日就被搞清了算法。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(三) ---- 数据保护和全盘加密]]></title>
      <url>/2017/04/09/18/</url>
      <content type="html"><![CDATA[<p>iOS提供全盘加密，还为开发者提供了数据保护的API，用于进一步保护自己的文件。这两个机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄露。</p>
<a id="more"></a>
<p>全盘加密其实解决了一个历史问题：用户数据会随设备一起被窃取。在笔记本或者台式机的环境下，如果想窃取数据，要么需要将硬盘转移到一个新机器上，要么引导一个操作系统来读取设备中的数据。文件系统加密并不能防止从一个正在运行的设备上窃取数据的行为。如果一个应用可以从磁盘中读取任意一个文件，那么文件系统加密其实是没有任何作用的，因为对于系统内核来说，任何尝试读取这些文件的进程都是透明解密的。相比于那些读文件的调用行为，文件系统加密工作在更底层。一旦攻击者攻破了系统验证，那他就能无障碍的读取任何文件。</p>
<p>iOS设备通常是全天运行设计，他们的内部存储器不容易被拆卸。如果一个攻击者想要不通过验证就从设备中读取敏感信息，他必须把设备完全拆解，然后将闪存存储器连接到一个自定义的接口上来读取数据。不过从设备中获取数据有更为简单的方法，而不用拆手机(毕竟拆手机这种事情一般人也做不来)：代码执行漏洞、越狱等。</p>
<p>iOS的全盘文件系统加密对于安全删除文件和远程设备擦除。传统的安全擦除文件的方法不适用于iOS设备，因为iOS设备主要使用固态硬盘(SSD)作为存储。固态硬盘的原理这里不再赘述，相信大家也都了解一些。SSD采用了减少磨损的机制，因此覆盖文件的操作无法保证真正覆盖硬盘中的旧数据。但是这不意味着我们对此束手无策，解决方法是确保文件被一个安全位置上的密钥加密，这样请求销毁数据的时候，可以直接丢弃密钥。iOS设备中使用的加密密钥是分层级的，只需要简单地丢弃一个加密密钥就能彻底销毁底层的数据，甚至是销毁整个文件系统(不得不说当时设计这个规则的人是真厉害)。</p>
<h2 id="加密密钥的层级："><a href="#加密密钥的层级：" class="headerlink" title="加密密钥的层级："></a>加密密钥的层级：</h2><p>分层级的加密密钥其实是说用密钥来加密其他密钥，这样苹果就能更精确的控制数据什么时候可用。</p>
<p>它们的层级关系是这样的：</p>
<p>设备密钥+用户密码-&gt;层级密钥</p>
<p>设备密钥-&gt;文件系统密钥-&gt;层级密钥</p>
<p>层级密钥-&gt;文件密钥</p>
<p>文件密钥(File Key)针对每个文件单独生成，存储在文件的元数据中。不同级别的文件需要使用不同强度的加密密钥。</p>
<p>层级密钥(Class Key)的作用是专门为那些特殊数据提供不同级别的保护。在早先的iOS版本中，默认的保护等级是NSFileProtectionNone；但是从iOS5开始，默认的保护等级变成了NSFileProtectionCompleteUntilFirstUserAuthentication。</p>
<p>文件系统密钥(Filesystem Key)是一种全局加密密钥，当元数据被层级密钥加密后，我们使用文件系统密钥来加密涉及文件安全的元数据。</p>
<p>设备密钥(Device Key)通常被称为UID密钥，每台设备唯一，只能通过硬件的AES引擎访问，操作系统无法直接获取。这是系统的主密钥，他用来加密文件系统密钥和层级密钥。如果用户启用了用户密码(User Passcode)，他将与设备密钥结合起来加密层级密钥。</p>
<p>一旦设置了用户密码，这个密钥等级也允许开发者自己决定本地存储的数据该如何被保护，包括：在设备锁定时能否被访问、数据能否备份到其它设备等。</p>
<h2 id="钥匙串API"><a href="#钥匙串API" class="headerlink" title="钥匙串API"></a>钥匙串API</h2><p>iOS提供了钥匙串API来存储少量机密信息。开发者可以用来存储密码、机密密钥以及那些不能被其他应用访问的敏感信息。调用钥匙串API主要通过securityd守护进程来完成，即从SQLite数据库中提取数据。开发者可以指定在什么情况下允许应用读取密钥，这和数据保护的API类似。</p>
<h2 id="数据保护API"><a href="#数据保护API" class="headerlink" title="数据保护API"></a>数据保护API</h2><p>数据保护API利用文件系统加密、钥匙串和用户密码，提供了一个额外的针对文件的保护层，开发者可以根据需求调用。这限制了某些进程在系统层面读取文件。这个API最常用的场景就是当设备锁定时确保数据不可用。</p>
<p>数据保护的强度在很大程度上取决于iOS的版本。随着版本更新，默认的数据保护等级会发生变化。在新创建的iOS应用程序中，数据保护默认对所有应用程序开启，这种状态在启动设备后的第一次解锁前都生效。你可以在项目的Capabilities里找到Data Protection这个选项。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你真的了解位运算？用了这个运算符，算法的时间复杂度竟然降了一个数量级！]]></title>
      <url>/2017/04/06/14/</url>
      <content type="html"><![CDATA[<p>其实这个运算符很容易被人忽略，他就是C语言中的位异或运算符^<br>位运算符家族中，最常用的，莫过于异或运算符。</p>
<a id="more"></a>
<p>我们先看异或运算符的定义： 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。<br>即：0^0=0， 1^0=1， 0^1=1， 1^1=0</p>
<p>例如：10100001^00010001=10110000<br>0^0=0,0^1=1    可理解为： 0异或任何数，其结果=任何数<br>1^0=1,1^1=0    可理解为： 1异或任何数，其结果=任何数取反<br>任何数异或自己，等于把自己置0</p>
<p>通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a，b的值，可通过下列语句实现：<br>a=10100001,   b=00000110<br>a=a^b； 　　//a=10100111<br>b=b^a； 　　//b=10100001<br>a=a^b； 　　//a=00000110</p>
<p>异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.</p>
<p>利用他的特点，我们可以解决一个常见的问题：<br>Single Number: 整数型数组中，每个元素均出现两次，除了一个元素例外，如何找出这个元素？能否设计一个线性时间的算法，且不需要额外的存储空间？</p>
<p>其实O(n)的算法不容易一下子想到，先说说常规的解决思路，有如下两种：<br>1、对元素的出现次数进行统计，可进行n*n循环，判断元素是否只出现了一次。这样时间复杂度为O(n^2), 不需要额外空间。<br>2、先对元素进行排序，然后进行相邻两元素的对比，如a1和a2对比，a3和a4对比，如果不同，则前一个元素(a1、a3)就是所要查找的元素。<br>这两种解法的时间复杂度都比O(n)更高。但是，如果你运用了异或运算符的特点，那么这个问题就很容易解决了，算法复杂度为O(n)，且不需要额外空间，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(int A[], int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result ^=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Xcode单元测试，你必须知道的18个知识]]></title>
      <url>/2017/04/06/31/</url>
      <content type="html"><![CDATA[<p>关于Xcode的单元测试，有些方法你是必须知道的。<br><a id="more"></a></p>
<ol>
<li><p>XCTFail(format…) 生成一个失败的测试；</p>
</li>
<li><p>XCTAssertNil(a1, format…)为空判断，a1为空时通过，反之不通过；</p>
</li>
<li><p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p>
</li>
<li><p>XCTAssert(expression, format…)当expression求值为TRUE时通过；</p>
</li>
<li><p>XCTAssertTrue(expression, format…)当expression求值为TRUE时通过；</p>
</li>
<li><p>XCTAssertFalse(expression, format…)当expression求值为False时通过；</p>
</li>
<li><p>XCTAssertEqualObjects(a1, a2, format…)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p>
</li>
<li><p>XCTAssertNotEqualObjects(a1, a2, format…)判断不等，[a1 isEqual:a2]值为False时通过；</p>
</li>
<li><p>XCTAssertEqual(a1, a2, format…)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p>
</li>
<li><p>XCTAssertNotEqual(a1, a2, format…)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p>
</li>
<li><p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format…)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p>
</li>
<li><p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format…) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p>
</li>
<li><p>XCTAssertThrows(expression, format…)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p>
</li>
<li><p>XCTAssertThrowsSpecific(expression, specificException, format…) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p>
</li>
<li><p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>
</li>
<li><p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p>
</li>
<li><p>XCTAssertNoThrowSpecific(expression, specificException, format…)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>
</li>
<li><p>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format…)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>
</li>
</ol>
<p>特别注意下XCTAssertEqualObjects和XCTAssertEqual。</p>
<p>XCTAssertEqualObjects(a1, a2, format…)的判断条件是[a1 isEqual:a2]是否返回一个YES。</p>
<p>XCTAssertEqual(a1, a2, format…)的判断条件是a1 == a2是否返回一个YES。</p>
<p>对于后者，如果a1和a2都是基本数据类型变量，那么只有a1 == a2才会返回YES。</p>
]]></content>
      
        
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(二) ---- 沙盒机制]]></title>
      <url>/2017/03/26/17/</url>
      <content type="html"><![CDATA[<p>苹果的沙盒机制想必大家都听过，并且都会称赞这是iOS做的比安卓系统好的一个重要因素，沙盒机制让iOS更为安全。</p>
<a id="more"></a>
<p>沙盒机制历史上被称作安全带，是一种基于FreeBSD系统(是一种类UNIX操作系统，是由经过BSD、386BSD和4.4BSD发展而来的Unix的一个重要分支)TrustedBSD框架的强制访问控制(MAC)机制，他的主要推动者是罗伯特沃森。这里我只是简单介绍一下，详细的信息以及介绍可以看这里<a href="http://shouce.jb51.net/freebsd-arch-handbook/mac.html" target="_blank" rel="noopener">TrustedBSD MAC框架介绍</a>，这份文档写得十分详尽，感兴趣的读者可以看看。</p>
<p>言归正题，沙盒机制采用一种类似于Lisp的配置语言来描述那些资源系统可以访问，哪些禁止访问。这些资源包括文件、系统服务、网络连接、内存资源等。MAC机制不同于传统的访问控制机制(比如自主访问控制DAC)，他不允许主体(比如用户进程)操作对象(文件、套接字等)。DAC最常见的形式就是Unix系统上的用户、组和其它权限，所有这些都可以被授予读、写或执行的权限。在DAC系统中，用户如果拥有了一个对象的所有权，也就拥有了该对象的修改权限。例如，你有一个文件，你可以将其设置为全局可读或可写，这显然是破坏了访问机制。</p>
<p>MAC是一个广义的术语，在沙盒中意味着应用程序被关进了一个虚拟的容器。该容器遵循一系列的特定规则，即哪些系统资源可以被访问，比如网络资源、文件读写、进程克隆等。在OS X中你可以部分控制应用程序的沙盒功能，但是在iOS中，所有的第三方应用都要遵循唯一的限制策略。</p>
<p>在文件访问方面，一般只能访问应用程序的包目录。应用程序可以读写存储在该位置的文件。不过这一基本规则存在少许的例外。例如，在某些iOS版本中，图片一般存储在目录/private/var/mobile/Media/Photos/ 中。尽管它在应用程序的包目录之外，但第三方应用还是可以直接访问，这样应用程序就无需获得用户许可就能访问系统相册，在之前的iOS版本中，如果想要阻止应用程序滥用权力，就只能将希望寄托在苹果审核的身上。但是在最新的iOS10系统里，所有访问操作都必须经过授权，而且在应用开发时必须将要使用到的权限(如相册、相机、麦克风)写入plist文件中，不然应用程序在使用到这些API时会崩溃，而且审核应用时一定会被拒绝。</p>
<p>安卓的访问控制机制与MAC不同。安卓实现了一个更加传统的DAC模型，应用程序都有自己的用户ID和属于该ID的文件夹，其权限管理严格按照传统的Unix文件权限管理运作。虽然两种机制工作起来都没有问题，但是MAC的扩展性总体来说还是要更强一些。例如，除了应用目录隔离，MAC机制还可以限制网络访问或守护系统进程的操作。</p>
<h2 id="术语解析-详情请点文中链接查看-："><a href="#术语解析-详情请点文中链接查看-：" class="headerlink" title="术语解析(详情请点文中链接查看)："></a>术语解析(详情请点文中链接查看)：</h2><p>FreeBSD： 以一个内核安全扩展性框架(TrustedBSD MAC 框架)的方式，为若干强制访问控制策略(也称“集权式访问控制策略”) 提供试验性支持。MAC 框架是一个插入式的访问控制框架，允许新的安全策略更方便地融入内核：安全策略可以静态链入内核,也可以 在引导时加载,甚至在运行时动态加载。该框架所提供的标准化接口,使得运行在其上的安全策略模块能对系统对象的安全属性进行诸如标记等一系列操作。 MAC 框架的存在，简化了这些操作在策略模块中的实现，从而显著降低了新安全策略模块的开发难度。</p>
<p>TrustedBSD：MAC 框架提供的机制,允许在其上运行的内核模块在内核编译或者运行时，对内核的访问控制模型进行扩展。 新的系统安全策略作为一个内核模块实现,并被链接到内核中；如果系统中同时存在多个安全策略模块，则它们的决策结果将以某种确定的方式组合。 为了给简化新安全策略的开发，MAC 向上提供了大量用于访问控制的基础设施，特别是对临时的或者持久的、策略无关的对象安全标记的支持。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 安全模型浅析(一) ---- 安全启动]]></title>
      <url>/2017/03/26/16/</url>
      <content type="html"><![CDATA[<p>就目前情况来说，AppStore确实成功的将很多恶意软件拒之门外，但是对于开发者来说，应用程序的审查就是一个黑箱操作。</p>
<a id="more"></a>
<p>苹果公司对应用的审查不会对外公开，所以你无法搞清楚他们是如何揪出你应用中那些不能使用的API。大部分时候你搞不清楚什么功能允许使用，什么功能禁止使用。但是苹果提供了正式的<a href="https://developer.apple.com/app-store/review/guidelines/" target="_blank" rel="noopener">指导手册</a>，但是很多遵循了执导的应用同样会被拒绝。</p>
<p>当然，什么是恶意程序是由苹果来定义的，苹果使用AppStore来控制或限制iOS平台上的应用程序的功能，这就意味着如果要实现某个特定的功能，唯一的手段就是要将设备越狱或者骗过应用商店的审查。比如通过某些特殊的操作(摇动手机XX次，出现一个控制按钮)开启隐藏功能。</p>
<p>官方的应用审查永远无法抓到那些钻空子的恶意软件，所以需要另外一套高效的机制来阻止恶意程序破坏操作系统的安全。在接下来的时间里，我会不定期的更新博客，介绍iOS的一些基本安全组件是如何阻止恶意攻击和保护数据的。</p>
<h2 id="首先介绍iOS的安全启动机制："><a href="#首先介绍iOS的安全启动机制：" class="headerlink" title="首先介绍iOS的安全启动机制："></a>首先介绍iOS的安全启动机制：</h2><p>当启动一台iOS设备时，系统首先会从只读的ROM中读取初始化指令，也就是系统的引导程序(事实上所有的操作系统启动时都要经过这一步，只是过程略有不同)。这个引导ROM包含苹果官方权威认证的公钥，他会验证底层启动加载器(LLB)的签名，一旦通过验证后就启动系统。LLB会所一些基础工作，然后验证第二级引导程序iBoot。iBoot启动后，设备就可以进入恢复模式或启动内核。在iBoot验证完内核签名的合法性之后，整个启动程序开始步入正轨：加载驱动程序、检测设备、启动系统守护进程。</p>
<p>这个信任链会确保所有的系统组件都有苹果官方写入、签名、分发，不能来自第三方机构，特别是那些恶意攻击者或者是给设备越狱的黑客。应用程序启动时也会用信任链去审查签名。所有的应用都必须直接或间接地由苹果签名(这就是为什么要申请开发者账号，生成开发和发布证书以及申请App ID的原因。很多开发者也经历过安装测试APP时提示你信任开发者证书，这些都是验证组件的功劳)。</p>
<p>越狱的工作原理正是攻击这一信任链。所有的越狱工具的作者都需要找到这一信任链上的漏洞，从而禁止掉信任链中负责验证的组件。破解引导ROM通常是最可取的办法，因为该组件不会因为苹果今后的软件更新而改变。</p>
]]></content>
      
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于数据结构和内存中堆和栈，你可能还不知道的几个区别]]></title>
      <url>/2017/03/16/15/</url>
      <content type="html"><![CDATA[<p>堆和栈是数据结构中最常见的两种结构。<br><a id="more"></a></p>
<ol>
<li><p>数据结构中的堆和栈<br>堆和栈在数据结构中是两种不同的数据结构。 两者都是数据项按序排列的数据结构。<br>栈：像是装数据的桶或者箱子<br>栈是大家比较熟悉的一种数据结构，它是一种具有后进先出的数据结构，也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放入比较晚的物体）。<br>堆：像是一颗倒立的大树<br>堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
</li>
<li><p>内存分配中的堆和栈<br>我们现在经常用的并不是数据结构中的堆和栈，之所以说了数据结构中的堆和栈是为了和后面将要说的堆区和栈区区别开来，请大家一定要注意。<br>下面说一下C语言程序内存分配中的堆和栈，这里有必要把内存分配也提一下，大家不要嫌弃本姑娘萝莉啰嗦啦，一般情况下 程序存放在Rom或Flash中，运行事需要拷贝到内存中执行，内存会分别存储不同的信息。</p>
</li>
</ol>
<p>内存中的栈区处于相对较高的地址，以地址的增长方向为上的话，栈地址是向下增长的。<br>栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的。只读区是分配常量和程序代码空间的；以及其他一些分区。</p>
<p>来看一个很经典的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;  全局初始化区</span><br><span class="line">char *p1;  全局未初始化区</span><br><span class="line">void main ()&#123;</span><br><span class="line">    int b; 栈</span><br><span class="line">    char  s[] = &quot;abc&quot;;栈</span><br><span class="line">    char *p2; 栈</span><br><span class="line">    char *p3 = &quot;123456&quot;; 123456\0 在常量区，p3 在栈区</span><br><span class="line">    static  int c = 0； 全局（静态）初始化区</span><br><span class="line">    p1 = (char *)malloc(10);堆</span><br><span class="line">    p2 = (char *)malloc (20);堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>内存分配中栈区和堆区的区别<br>0、申请方式和回收方式不同<br>不知道你是否有点明白了，堆和栈的第一个区别就是申请方式的不同：栈（英文名字;stack）是系统自动分配空间的<br>，例如我们定义了一个 char a ；系统会自动的在栈上为其开辟空间。而堆（英文名字:heap）则是程序员根据需要自己申请的空间，例如malloc(10); 开辟是个字节的空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。</li>
</ol>
<p>1、 申请后系统的响应<br>栈 ： 只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统受到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆。<br>结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题</p>
<p>2、申请效率的比较<br>栈：  由系统自动分配，速度较快。但程序员是无法控制的。<br>堆：  是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>
<p>3、 申请大小的限制<br>栈： 在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>4、堆和栈中的内存内容<br>由于栈的大小限制，所以用子函数还是有物理意义的，而不仅仅是逻辑意义。<br>栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的吓一跳可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是有右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>5、 关于堆和栈一个比较形象的比喻<br>栈：使用栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、吃（使用），吃饱了就走，不必理会切菜，洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处就是快捷，但是自由度小。</p>
<p>堆：使用堆就像是自己动手做喜欢的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 一直弹出登录iCloud的解决方法]]></title>
      <url>/2017/01/05/11/</url>
      <content type="html"><![CDATA[<p>一直弹出的时候，你随便输入密码，输三次，它会出现让你重设密码，然后点击重设，会出现网页，然后直接按home键就可以 ，前提是必须要连上网。<br><a id="more"></a></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac下如何查看Git的全局忽略列表]]></title>
      <url>/2016/11/22/6/</url>
      <content type="html"><![CDATA[<p>有时在使用Git的时候会发现有些文件明明在目录里，但是Git却没有自动添加到版本跟踪里面，查看仓库的忽略列表也没有，那么有很大可能是在Git的全局忽略列表里。</p>
<a id="more"></a>
<p>打开Finder(如果连这个都不知道的话，还是用回Windows吧)<br>在显示器的顶部菜单选择前往-&gt;前往文件夹<br>输入~/.gitignore_global</p>
<p>右键用记事本打开即可</p>
<p>如果不显示，请允许Mac显示所有隐藏文件！！<br>打开终端，输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true       此命令显示隐藏文件</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool false      此命令关闭显示隐藏文件</span><br></pre></td></tr></table></figure></p>
<p>命令运行之后需要重新加载Finder：快捷键option+command+esc，选中Finder，重新启动即可<br>重启电脑也可以。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift3 单例模式]]></title>
      <url>/2016/11/16/8/</url>
      <content type="html"><![CDATA[<p>单例模式是开发中很常用的一种设计模式，一般几十行甚至十几行代码就可以搞定，Swift里面有这么几种单例的写法，供大家参考。</p>
<a id="more"></a>
<p>常见的有这么几种方法</p>
<ol>
<li>第一种<br>最简单也是最常用的，这里的所有单例init方法一定要定义成private的，不然外部依然可以使用init方法初始化变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final class Single: NSObject &#123;</span><br><span class="line">    static let shared = Single()</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>final关键字的作用是这个类或方法不希望被继承和重写</p>
<ol>
<li>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public extension DispatchQueue &#123;</span><br><span class="line">    private static var onceToken = [String]()</span><br><span class="line">    public class func once(_ token: String, _ block:@escaping () -&gt; Void) &#123;</span><br><span class="line">        objc_sync_enter(self)</span><br><span class="line">        defer &#123;</span><br><span class="line">            objc_sync_exit(self)</span><br><span class="line">        &#125;</span><br><span class="line">        if onceToken.contains(token) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        onceToken.append(token)</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Single2: NSObject &#123;</span><br><span class="line">    static func shared() -&gt; Single2 &#123;</span><br><span class="line">        struct Singleton &#123;</span><br><span class="line">            static var single = Single2()</span><br><span class="line">        &#125;</span><br><span class="line">        DispatchQueue.once(&quot;paradiseduo&quot;) &#123;</span><br><span class="line">            Singleton.single = shared()</span><br><span class="line">        &#125;</span><br><span class="line">        return Singleton.single</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第二种完全是OC风格的单例，但是由于Swift3中废弃了原来的dispatch_once_t，所以需要先给DispatchQueue添加一个extension，实现原先的dispatch_once_t效果</p>
<ol>
<li><p>第三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private let single = Single3()</span><br><span class="line">final class Single3: NSObject &#123;</span><br><span class="line">    static var shared: Single3 &#123;</span><br><span class="line">        return single</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileprivate override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final class Single4: NSObject &#123;</span><br><span class="line">    static var shared: Single4 &#123;</span><br><span class="line">        struct Static &#123;</span><br><span class="line">            static let instance: Single4 = Single4()</span><br><span class="line">        &#125;</span><br><span class="line">        return Static.instance</span><br><span class="line">    &#125;</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方法的实现原理是在方法内定义静态变量</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设置Git区分文件名大小写]]></title>
      <url>/2016/11/16/5/</url>
      <content type="html"><![CDATA[<p>git 默认不区分文件名大小写。</p>
<a id="more"></a>
<p>当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.</p>
<p>然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.</p>
<p>控制台输入git status 也不显示任何信息</p>
<p>那么就配置git 使其对文件名大小写敏感，直接在终端中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree(Git)不识别新添加的文件]]></title>
      <url>/2016/11/16/10/</url>
      <content type="html"><![CDATA[<p>今天在做项目的时候新建了一个viewController，但是sourceTree只显示新增了.h文件，在网上找了许多方法发现没有用，比如那个删掉.git隐藏文件的，删掉就SB了。</p>
<a id="more"></a>
<p>找了好久没找到，无奈只能自己试验了。</p>
<p>工作目录中，新建一个文件，比如一个.h和.m文件。</p>
<p>但是，git无法识别这些文件。</p>
<p>用git status命令，返回目录是clean的。表明没有任何修改。说明git没有识别到这些新增加的文件。也说明这个问题是git内部的问题，跟用什么版本控制工具没关系（不是sourcetree的锅）</p>
<p>首先，找到了原因，那么强制给他加一下，用终端到文件目录下，然后输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add 1.m</span><br></pre></td></tr></table></figure></p>
<p>返回无法添加，说1.m已经处于.gitignore中。但是iganore中明明没有忽略这些m文件。</p>
<p>那就更狠一点，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f 1.m</span><br></pre></td></tr></table></figure></p>
<p>这样就可以将1.m添加到git的版本控制中。</p>
<p>如果直接git add -f 1.m</p>
<p>报错，无法找到文件1.m</p>
<p>那么就将1.m的完整路径输入即可。</p>
<p>建议先看一下全局忽略列表里有没有，查看Git全局忽略列表的方法在我的另一篇文章中有，请自行查阅。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 中的for循环，正序与逆序(倒序)]]></title>
      <url>/2016/11/02/9/</url>
      <content type="html"><![CDATA[<p>看了许多关于Swift  for循环的文章，发现基本上都是正序的for循环，对于逆序的我一直使用while循环，直到我发现了这个方法。。。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in (0...10).reversed() &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用这个就可以倒序for循环了</p>
<p>还有另一种比较优雅而且装X的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 3, through: 0, by: -1) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Swift 的 stride 函数返回一个任意可变步长 类型值的序列。可变步长类型是可以设置偏移量的一维标量。<br>他有两个变种，<br>from，to，最后一个值将会严格小(大)于to的值<br>stride(from:3, to:0, by:-1) 表示3，2，1</p>
<p>from，through，最后一个值将会小(大)于等于through的值<br>stride(from:3, through:0, by:-1) 表示3，2，1，0</p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree超前一个版本，落后N个版本]]></title>
      <url>/2016/10/08/1/</url>
      <content type="html"><![CDATA[<p>在使用SourceTree的时候经常会遇见超前一个版本，落后N个版本的情况，遇见这种情况应该怎么办呢？</p>
<a id="more"></a>
<p>首先打开终端，最好是从SourceTree里面打开，菜单栏有个终端按钮。</p>
<p>然后输入(不要用这个，用下面的)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是将自己最近的一次提交撤销，回到push之前的状态。但是所有commit的内容就都消失了。非常不建议用这个参数，会牺牲太多的代码。。<br>如果不想让commit消失，可以改一下参数。用这个参数可以保证你提交的代码原封不动的保存下来。前提是你本地的工作台是干净的。如果不是请把所有代码都暂存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD^</span><br></pre></td></tr></table></figure></p>
<p>执行这句话之后重新拉取一遍代码就可以了，push的都会撤销回来。</p>
<p>如果想一次回退多个push，可以这样：(例子是撤销最近三次的提交)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~3</span><br></pre></td></tr></table></figure></p>
<p>如果想回退到某个指定版本，在终端中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft 1234567</span><br></pre></td></tr></table></figure></p>
<p>1234567是要回退到的版本号，根据具体情况而定，这里只是举例子。<br>版本号可以不写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>版本号可以不写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>最后总结一下：</p>
<ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSProcessInfo类方法]]></title>
      <url>/2016/08/26/13/</url>
      <content type="html"><![CDATA[<p>NSProcessInfo类中的方法很有用。<br><a id="more"></a><br>let i =NSProcessInfo.processInfo()<br>print(i.systemUptime)          //返回系统的运行时长<br>print(i.processName)           //返回当前正在执行的进程名称<br>print(i.arguments)             //以NSString对象数组的形式返回当前进程的参数<br>print(i.environment)           //返回变量/值对词典，以描述当前的环境变量（比如PATH和HOME）及其值<br>print(i.processIdentifier)     //返回进程标识符，它是操作系统赋予进程的唯一数字，用于识别每个正在运行的进程<br>print(i.processorCount)        //返回线程数量<br>print(i.globallyUniqueString)  //每次调用这个方法时，都返回不同的单值字符串，可以用这个字符串生成单值临时文件名<br>print(i.hostName)              //返回主机系统的名称（在笔者的iOS系统中，返回的是iPhone）<br>print(i.operatingSystemVersion)//返回操作系统的版本<br>print(i.operatingSystemVersionString)//返回操作系统的版本以及build号</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS获取当前版本号 Bundle ID等信息的方法]]></title>
      <url>/2016/08/23/7/</url>
      <content type="html"><![CDATA[<p>很多地方都会用到获取当前App的版本号。</p>
<a id="more"></a>
<p>1：获取bundle Id信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle mainBundle] bundleIdentifier];</span><br></pre></td></tr></table></figure></p>
<p>2：获取版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];</span><br></pre></td></tr></table></figure></p>
<p>3：获取build号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleVersion&quot;];</span><br></pre></td></tr></table></figure></p>
<p>4：获取App显示名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[NSBundle mainBundle]infoDictionary] objectForKey:@&quot;CFBundleDisplayName&quot;];</span><br></pre></td></tr></table></figure></p>
<p>其实 [[NSBundle mainBundle]infoDictionary] 获得的是一个字典，里边放着Info.plist文件中的各种信息，根据不同的键去即可，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CFBundleDevelopmentRegion</span><br><span class="line"></span><br><span class="line">CFBundleDisplayName</span><br><span class="line"></span><br><span class="line">CFBundleExecutable</span><br><span class="line"></span><br><span class="line">CFBundleExecutablePath</span><br><span class="line"></span><br><span class="line">CFBundleIdentifier</span><br><span class="line"></span><br><span class="line">CFBundleInfoDictionaryVersion = &quot;6.0&quot;;</span><br><span class="line"></span><br><span class="line">CFBundleInfoPlistURL</span><br><span class="line"></span><br><span class="line">CFBundleName</span><br><span class="line"></span><br><span class="line">CFBundlePackageType</span><br><span class="line"></span><br><span class="line">CFBundleShortVersionString</span><br><span class="line"></span><br><span class="line">CFBundleSignature</span><br><span class="line"></span><br><span class="line">CFBundleSupportedPlatforms</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
